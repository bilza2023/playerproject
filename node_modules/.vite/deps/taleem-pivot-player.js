import "./chunk-X7HCJ7ZS.js";
import {
  require_howler
} from "./chunk-TBSMVHWT.js";
import "./chunk-DYWWDCTU.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  assign,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_spread_object,
  get_spread_update,
  get_svelte_dataset,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  to_number,
  toggle_class,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-CVLNV7PT.js";
import "./chunk-672HPU4M.js";
import {
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/taleem-pivot-player/Player.js
var import_howler = __toESM(require_howler());
var Player = class {
  constructor(soundUrl) {
    this.sound = new import_howler.Howl({
      src: [soundUrl],
      html5: true
    });
    this._tickCbs = [];
    this._intervalId = null;
    this.sound.on("play", () => this._startTickLoop());
    this.sound.on("pause", () => this._clearTickLoop());
    this.sound.on("stop", () => this._clearTickLoop());
    this.sound.on("end", () => this._clearTickLoop());
  }
  play() {
    this.sound.play();
  }
  pause() {
    this.sound.pause();
  }
  onTick(cb, interval = 200) {
    this._tickCbs.push(cb);
    if (this.sound.playing() && !this._intervalId) {
      this._startTickLoop(interval);
    }
  }
  _startTickLoop(interval = 200) {
    this._clearTickLoop();
    this._intervalId = setInterval(() => {
      const currentTime = this.sound.seek();
      this._tickCbs.forEach((fn) => fn(currentTime));
    }, interval);
  }
  _clearTickLoop() {
    if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = null;
    }
  }
  destroy() {
    this._clearTickLoop();
    this.sound.unload();
  }
};

// node_modules/taleem-pivot-player/slides/Quote.svelte
var file = "node_modules/taleem-pivot-player/slides/Quote.svelte";
function add_css(target) {
  append_styles(target, "svelte-1096xqm", ".quote-slide.svelte-1096xqm{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;text-align:center;padding:40px}.heading.svelte-1096xqm{font-size:68px;margin-bottom:0.8rem}.author-text.svelte-1096xqm{font-size:28px;opacity:0.85;margin-top:1.6rem}@media(max-width: 480px){.heading.svelte-1096xqm{font-size:32px}.author-text.svelte-1096xqm{font-size:18px}}@media(min-width: 481px) and (max-width: 767px){.heading.svelte-1096xqm{font-size:40px}.author-text.svelte-1096xqm{font-size:20px}}@media(min-width: 768px) and (max-width: 1024px){.heading.svelte-1096xqm{font-size:52px}.author-text.svelte-1096xqm{font-size:24px}}@media(min-width: 1025px) and (max-width: 1440px){.heading.svelte-1096xqm{font-size:60px}.author-text.svelte-1096xqm{font-size:26px}}@media(min-width: 1441px){.heading.svelte-1096xqm{font-size:120px}.author-text.svelte-1096xqm{font-size:35px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVvdGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL1F1b3RlLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let h1;
  let t_value = (
    /*line*/
    ctx[3].content + ""
  );
  let t;
  const block = {
    c: function create() {
      h1 = element("h1");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      h1 = claim_element(nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t = claim_text(h1_nodes, t_value);
      h1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "heading svelte-1096xqm");
      add_location(h1, file, 9, 4, 235);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h1, anchor);
      append_hydration_dev(h1, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(9:2) {#each quoteLines as line}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let t0;
  let p;
  let t1;
  let each_value = ensure_array_like_dev(
    /*quoteLines*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      p = element("p");
      t1 = text(
        /*author*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t0 = claim_space(div_nodes);
      p = claim_element(div_nodes, "P", { class: true });
      var p_nodes = children(p);
      t1 = claim_text(
        p_nodes,
        /*author*/
        ctx[1]
      );
      p_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "text-primary author-text svelte-1096xqm");
      add_location(p, file, 12, 2, 288);
      attr_dev(div, "class", "quote-slide svelte-1096xqm");
      add_location(div, file, 7, 0, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t0);
      append_hydration_dev(div, p);
      append_hydration_dev(p, t1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*quoteLines*/
      1) {
        each_value = ensure_array_like_dev(
          /*quoteLines*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Quote", slots, []);
  let { data } = $$props;
  const quoteLines = data.filter((d) => d.name === "quoteLine");
  const author = ((_a = data.find((d) => d.name === "author")) == null ? void 0 : _a.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Quote> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Quote> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, quoteLines, author });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [quoteLines, author, data];
}
var Quote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { data: 2 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Quote",
      options,
      id: create_fragment.name
    });
  }
  get data() {
    throw new Error("<Quote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Quote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Quote_default = Quote;

// node_modules/taleem-pivot-player/slides/CornerWords.svelte
var file2 = "node_modules/taleem-pivot-player/slides/CornerWords.svelte";
function add_css2(target) {
  append_styles(target, "svelte-118o6os", ".card-grid.svelte-118o6os{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;width:100%;height:100%;box-sizing:border-box}.card.svelte-118o6os{display:flex;flex-direction:column;justify-content:center;align-items:center;border:3px solid currentColor;border-radius:16px;box-sizing:border-box;width:100%;height:100%;padding:20px;text-align:center}.icon.svelte-118o6os{font-size:clamp(40px, 10vw, 80px);margin-bottom:12px}.label.svelte-118o6os{font-size:clamp(18px, 3vw, 28px);font-weight:bold;line-height:1.2}@media(max-width: 600px){.card.svelte-118o6os{padding:2px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29ybmVyV29yZHMuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL0Nvcm5lcldvcmRzLnN2ZWx0ZSJdfQ== */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div;
  let t_value = (
    /*card*/
    ctx[3].icon + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "icon svelte-118o6os");
      add_location(div, file2, 11, 8, 250);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(11:6) {#if card.showAt <= currentTime}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div1;
  let t0;
  let div0;
  let t1_value = (
    /*card*/
    ctx[3].label + ""
  );
  let t1;
  let t2;
  let if_block = (
    /*card*/
    ctx[3].showAt <= /*currentTime*/
    ctx[0] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, t1_value);
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "label svelte-118o6os");
      add_location(div0, file2, 13, 6, 304);
      attr_dev(div1, "class", "card svelte-118o6os");
      add_location(div1, file2, 9, 4, 184);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div1, t2);
    },
    p: function update(ctx2, dirty) {
      if (
        /*card*/
        ctx2[3].showAt <= /*currentTime*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(div1, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(9:2) {#each cards as card}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*cards*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "card-grid text-primary svelte-118o6os");
      add_location(div, file2, 7, 0, 119);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*cards, currentTime*/
      3) {
        each_value = ensure_array_like_dev(
          /*cards*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerWords", slots, []);
  let { data } = $$props;
  let { currentTime } = $$props;
  const cards = data.filter((d) => d.name === "card");
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<CornerWords> was created without expected prop 'data'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<CornerWords> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["data", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CornerWords> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(0, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({ data, currentTime, cards });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(0, currentTime = $$props2.currentTime);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [currentTime, cards, data];
}
var CornerWords = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { data: 2, currentTime: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerWords",
      options,
      id: create_fragment2.name
    });
  }
  get data() {
    throw new Error("<CornerWords>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<CornerWords>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<CornerWords>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<CornerWords>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerWords_default = CornerWords;

// node_modules/taleem-pivot-player/slides/Title.svelte
var file3 = "node_modules/taleem-pivot-player/slides/Title.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1rlf2bs", ".title-slide.svelte-1rlf2bs{display:flex;justify-content:center;align-items:center;height:100%;text-align:center;padding:40px;box-sizing:border-box}.main-title.svelte-1rlf2bs{font-weight:bold;line-height:1.2;text-wrap:balance;font-size:72px;text-shadow:8px 8px 22px var(--shadowColor)}@media(max-width: 480px){.main-title.svelte-1rlf2bs{font-size:36px}}@media(min-width: 481px) and (max-width: 767px){.main-title.svelte-1rlf2bs{font-size:48px}}@media(min-width: 768px) and (max-width: 1024px){.main-title.svelte-1rlf2bs{font-size:60px}}@media(min-width: 1025px) and (max-width: 1440px){.main-title.svelte-1rlf2bs{font-size:72px}}@media(min-width: 1441px){.main-title.svelte-1rlf2bs{font-size:100px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGl0bGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL1RpdGxlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment3(ctx) {
  let div;
  let h1;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      h1 = element("h1");
      t = text(
        /*title*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h1 = claim_element(div_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t = claim_text(
        h1_nodes,
        /*title*/
        ctx[0]
      );
      h1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "main-title svelte-1rlf2bs");
      add_location(h1, file3, 6, 4, 146);
      attr_dev(div, "class", "title-slide svelte-1rlf2bs");
      add_location(div, file3, 5, 2, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h1);
      append_hydration_dev(h1, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Title", slots, []);
  let { data } = $$props;
  const title = ((_a = data.find((d) => d.name === "title")) == null ? void 0 : _a.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Title> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Title> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, title });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, data];
}
var Title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { data: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Title",
      options,
      id: create_fragment3.name
    });
  }
  get data() {
    throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Title_default = Title;

// node_modules/taleem-pivot-player/slides/Image.svelte
var file4 = "node_modules/taleem-pivot-player/slides/Image.svelte";
function add_css4(target) {
  append_styles(target, "svelte-ucn0n7", ".image-slide.svelte-ucn0n7.svelte-ucn0n7{position:relative;width:100%;height:100%;padding:0;display:flex;justify-content:center;align-items:center;box-sizing:border-box}.full-image.svelte-ucn0n7.svelte-ucn0n7{width:auto;height:auto;max-width:90vw;max-height:90vh;aspect-ratio:16 / 9;-o-object-fit:contain;object-fit:contain;border-radius:12px;box-shadow:0 0 30px rgba(0, 0, 0, 0.2)}@media(max-width: 480px){.image-slide.svelte-ucn0n7.svelte-ucn0n7{padding:20px}.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:300px}}@media(min-width: 481px) and (max-width: 767px){.image-slide.svelte-ucn0n7.svelte-ucn0n7{padding:30px}.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:400px}}@media(min-width: 768px) and (max-width: 1024px){.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:500px}}@media(min-width: 1025px) and (max-width: 1440px){.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:600px}}@media(min-width: 1441px){.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:900px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL0ltYWdlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment4(ctx) {
  let div;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      img = claim_element(div_nodes, "IMG", { class: true, src: true, alt: true });
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "class", "full-image svelte-ucn0n7");
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      add_location(img, file4, 8, 4, 200);
      attr_dev(div, "class", "image-slide svelte-ucn0n7");
      add_location(div, file4, 6, 2, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Image> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Image> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, data];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { data: 1 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment4.name
    });
  }
  get data() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/taleem-pivot-player/slides/ImageLeftBulletsRight.svelte
var file5 = "node_modules/taleem-pivot-player/slides/ImageLeftBulletsRight.svelte";
function add_css5(target) {
  append_styles(target, "svelte-cq9z6", ".slide-container.svelte-cq9z6.svelte-cq9z6{display:flex;height:100%;width:100%;box-sizing:border-box;padding:40px;gap:60px}.image-left.svelte-cq9z6 img.svelte-cq9z6{max-height:80vh;max-width:40vw;-o-object-fit:contain;object-fit:contain;border-radius:12px}.bullets-right.svelte-cq9z6.svelte-cq9z6{flex:1;display:flex;align-items:center;justify-content:center}.bullets-right.svelte-cq9z6 ul.svelte-cq9z6{list-style-type:disc;padding-left:1.5rem;font-size:4.5rem}.bullets-right.svelte-cq9z6 li.svelte-cq9z6{margin-bottom:1rem}@media(max-width: 768px){.slide-container.svelte-cq9z6.svelte-cq9z6{flex-direction:column;align-items:center}.bullets-right.svelte-cq9z6 ul.svelte-cq9z6{font-size:2rem}.image-left.svelte-cq9z6 img.svelte-cq9z6{max-width:80vw}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VMZWZ0QnVsbGV0c1JpZ2h0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NsaWRlcy9JbWFnZUxlZnRCdWxsZXRzUmlnaHQuc3ZlbHRlIl19 */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = /*imageItem*/
      ctx[1].content)) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide image");
      attr_dev(img, "class", "svelte-cq9z6");
      add_location(img, file5, 15, 6, 382);
      attr_dev(div, "class", "image-left svelte-cq9z6");
      add_location(div, file5, 14, 4, 351);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, img);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*imageItem*/
      2 && !src_url_equal(img.src, img_src_value = /*imageItem*/
      ctx2[1].content)) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(14:2) {#if imageItem}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let li;
  let t_value = (
    /*bullet*/
    ctx[4] + ""
  );
  let t;
  const block = {
    c: function create() {
      li = element("li");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t = claim_text(li_nodes, t_value);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "svelte-cq9z6");
      add_location(li, file5, 21, 8, 530);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*bullets*/
      1 && t_value !== (t_value = /*bullet*/
      ctx2[4] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(21:6) {#each bullets as bullet}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div1;
  let t;
  let div0;
  let ul;
  let if_block = (
    /*imageItem*/
    ctx[1] && create_if_block2(ctx)
  );
  let each_value = ensure_array_like_dev(
    /*bullets*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block) if_block.c();
      t = space();
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block) if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      ul = claim_element(div0_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "svelte-cq9z6");
      add_location(ul, file5, 19, 4, 485);
      attr_dev(div0, "class", "bullets-right svelte-cq9z6");
      add_location(div0, file5, 18, 2, 453);
      attr_dev(div1, "class", "slide-container svelte-cq9z6");
      add_location(div1, file5, 12, 0, 299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block) if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*imageItem*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*bullets*/
      1) {
        each_value = ensure_array_like_dev(
          /*bullets*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block) if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let imageItem;
  let bullets;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageLeftBulletsRight", slots, []);
  let { data } = $$props;
  let { currentTime } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageLeftBulletsRight> was created without expected prop 'data'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<ImageLeftBulletsRight> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["data", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageLeftBulletsRight> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(3, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({ data, currentTime, bullets, imageItem });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(3, currentTime = $$props2.currentTime);
    if ("bullets" in $$props2) $$invalidate(0, bullets = $$props2.bullets);
    if ("imageItem" in $$props2) $$invalidate(1, imageItem = $$props2.imageItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data, currentTime*/
    12) {
      $: $$invalidate(1, imageItem = data.find((d) => d.name === "image" && d.showAt <= currentTime));
    }
    if ($$self.$$.dirty & /*data, currentTime*/
    12) {
      $: $$invalidate(0, bullets = data.filter((d) => d.name === "bullet" && d.showAt <= currentTime).sort((a, b) => a.showAt - b.showAt).map((d) => d.content));
    }
  };
  return [bullets, imageItem, data, currentTime];
}
var ImageLeftBulletsRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { data: 2, currentTime: 3 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageLeftBulletsRight",
      options,
      id: create_fragment5.name
    });
  }
  get data() {
    throw new Error("<ImageLeftBulletsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageLeftBulletsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<ImageLeftBulletsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<ImageLeftBulletsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageLeftBulletsRight_default = ImageLeftBulletsRight;

// node_modules/taleem-pivot-player/slides/ImageRightBulletsLeft.svelte
var file6 = "node_modules/taleem-pivot-player/slides/ImageRightBulletsLeft.svelte";
function add_css6(target) {
  append_styles(target, "svelte-u443z4", ".slide-container.svelte-u443z4.svelte-u443z4{display:flex;height:100%;width:100%;box-sizing:border-box;padding:40px;gap:60px}.image-right.svelte-u443z4 img.svelte-u443z4{max-height:80vh;max-width:40vw;-o-object-fit:contain;object-fit:contain;border-radius:12px}.bullets-left.svelte-u443z4.svelte-u443z4{flex:1;display:flex;align-items:center;justify-content:center}.bullets-left.svelte-u443z4 ul.svelte-u443z4{list-style-type:disc;padding-left:1.5rem;font-size:4.5rem}.bullets-left.svelte-u443z4 li.svelte-u443z4{margin-bottom:1rem}@media(max-width: 768px){.slide-container.svelte-u443z4.svelte-u443z4{flex-direction:column;align-items:center}.bullets-left.svelte-u443z4 ul.svelte-u443z4{font-size:2rem}.image-right.svelte-u443z4 img.svelte-u443z4{max-width:80vw}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VSaWdodEJ1bGxldHNMZWZ0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NsaWRlcy9JbWFnZVJpZ2h0QnVsbGV0c0xlZnQuc3ZlbHRlIl19 */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let li;
  let t_value = (
    /*bullet*/
    ctx[4] + ""
  );
  let t;
  const block = {
    c: function create() {
      li = element("li");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t = claim_text(li_nodes, t_value);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "svelte-u443z4");
      add_location(li, file6, 16, 8, 407);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*bullets*/
      1 && t_value !== (t_value = /*bullet*/
      ctx2[4] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(16:6) {#each bullets as bullet}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      img = claim_element(div_nodes, "IMG", { src: true, alt: true, class: true });
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = /*imageItem*/
      ctx[1].content)) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide image");
      attr_dev(img, "class", "svelte-u443z4");
      add_location(img, file6, 23, 6, 513);
      attr_dev(div, "class", "image-right svelte-u443z4");
      add_location(div, file6, 22, 4, 481);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, img);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*imageItem*/
      2 && !src_url_equal(img.src, img_src_value = /*imageItem*/
      ctx2[1].content)) {
        attr_dev(img, "src", img_src_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(22:2) {#if imageItem}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div1;
  let div0;
  let ul;
  let t;
  let each_value = ensure_array_like_dev(
    /*bullets*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  let if_block = (
    /*imageItem*/
    ctx[1] && create_if_block3(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block) if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      ul = claim_element(div0_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (if_block) if_block.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "svelte-u443z4");
      add_location(ul, file6, 14, 4, 362);
      attr_dev(div0, "class", "bullets-left svelte-u443z4");
      add_location(div0, file6, 13, 2, 331);
      attr_dev(div1, "class", "slide-container svelte-u443z4");
      add_location(div1, file6, 12, 0, 299);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append_hydration_dev(div1, t);
      if (if_block) if_block.m(div1, null);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*bullets*/
      1) {
        each_value = ensure_array_like_dev(
          /*bullets*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*imageItem*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_each(each_blocks, detaching);
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let imageItem;
  let bullets;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageRightBulletsLeft", slots, []);
  let { data } = $$props;
  let { currentTime } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageRightBulletsLeft> was created without expected prop 'data'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<ImageRightBulletsLeft> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["data", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageRightBulletsLeft> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(3, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({ data, currentTime, bullets, imageItem });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(3, currentTime = $$props2.currentTime);
    if ("bullets" in $$props2) $$invalidate(0, bullets = $$props2.bullets);
    if ("imageItem" in $$props2) $$invalidate(1, imageItem = $$props2.imageItem);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data, currentTime*/
    12) {
      $: $$invalidate(1, imageItem = data.find((d) => d.name === "image" && d.showAt <= currentTime));
    }
    if ($$self.$$.dirty & /*data, currentTime*/
    12) {
      $: $$invalidate(0, bullets = data.filter((d) => d.name === "bullet" && d.showAt <= currentTime).sort((a, b) => a.showAt - b.showAt).map((d) => d.content));
    }
  };
  return [bullets, imageItem, data, currentTime];
}
var ImageRightBulletsLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { data: 2, currentTime: 3 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageRightBulletsLeft",
      options,
      id: create_fragment6.name
    });
  }
  get data() {
    throw new Error("<ImageRightBulletsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageRightBulletsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<ImageRightBulletsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<ImageRightBulletsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageRightBulletsLeft_default = ImageRightBulletsLeft;

// node_modules/taleem-pivot-player/slides/ImageWithCaption.svelte
var file7 = "node_modules/taleem-pivot-player/slides/ImageWithCaption.svelte";
function add_css7(target) {
  append_styles(target, "svelte-17cvzhn", ".image-slide.svelte-17cvzhn{position:relative;width:100%;height:100%;display:flex;justify-content:center;align-items:center}.full-image.svelte-17cvzhn{max-width:90vw;max-height:90vh;-o-object-fit:contain;object-fit:contain;border-radius:12px;box-shadow:0 0 30px rgba(0, 0, 0, 0.2)}.text-overlay.caption.svelte-17cvzhn{position:absolute;bottom:5%;left:50%;transform:translateX(-50%);font-size:2.5rem;color:white;text-shadow:1px 1px 4px black}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VXaXRoQ2FwdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zbGlkZXMvSW1hZ2VXaXRoQ2FwdGlvbi5zdmVsdGUiXX0= */");
}
function create_fragment7(ctx) {
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let t1;
  const block = {
    c: function create() {
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      t1 = text(
        /*caption*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      img = claim_element(div1_nodes, "IMG", { class: true, src: true, alt: true });
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(
        div0_nodes,
        /*caption*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "class", "full-image svelte-17cvzhn");
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      add_location(img, file7, 7, 4, 222);
      attr_dev(div0, "class", "text-overlay caption svelte-17cvzhn");
      add_location(div0, file7, 8, 4, 286);
      attr_dev(div1, "class", "image-slide svelte-17cvzhn");
      add_location(div1, file7, 6, 2, 192);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, img);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageWithCaption", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  const caption = ((_b = data.find((d) => d.name === "caption")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageWithCaption> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageWithCaption> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc, caption });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, caption, data];
}
var ImageWithCaption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { data: 2 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageWithCaption",
      options,
      id: create_fragment7.name
    });
  }
  get data() {
    throw new Error("<ImageWithCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageWithCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageWithCaption_default = ImageWithCaption;

// node_modules/taleem-pivot-player/slides/ImageWithTitle.svelte
var file8 = "node_modules/taleem-pivot-player/slides/ImageWithTitle.svelte";
function add_css8(target) {
  append_styles(target, "svelte-1llvupf", ".slide-container.svelte-1llvupf.svelte-1llvupf{display:flex;flex-direction:column;align-items:center;padding:20px;box-sizing:border-box;height:100%;width:100%;gap:20px}.title-zone.svelte-1llvupf.svelte-1llvupf{text-align:center}.slide-title.svelte-1llvupf.svelte-1llvupf{padding-top:4rem;font-size:4rem;margin:0}.image-zone.svelte-1llvupf.svelte-1llvupf{max-width:70%;max-height:70%;display:flex;justify-content:center}.image-zone.svelte-1llvupf img.svelte-1llvupf{max-width:100%;height:auto;-o-object-fit:contain;object-fit:contain}@media(max-width: 768px){.slide-title.svelte-1llvupf.svelte-1llvupf{font-size:1.5rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VXaXRoVGl0bGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL0ltYWdlV2l0aFRpdGxlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment8(ctx) {
  let div2;
  let div0;
  let h1;
  let t0;
  let t1;
  let div1;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      h1 = element("h1");
      t0 = text(
        /*title*/
        ctx[1]
      );
      t1 = space();
      div1 = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      h1 = claim_element(div0_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*title*/
        ctx[1]
      );
      h1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      img = claim_element(div1_nodes, "IMG", { src: true, alt: true, class: true });
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "slide-title svelte-1llvupf");
      add_location(h1, file8, 9, 4, 238);
      attr_dev(div0, "class", "title-zone svelte-1llvupf");
      add_location(div0, file8, 8, 2, 209);
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      attr_dev(img, "class", "svelte-1llvupf");
      add_location(img, file8, 12, 4, 315);
      attr_dev(div1, "class", "image-zone svelte-1llvupf");
      add_location(div1, file8, 11, 2, 286);
      attr_dev(div2, "class", "slide-container svelte-1llvupf");
      add_location(div2, file8, 7, 0, 177);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageWithTitle", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  const title = ((_b = data.find((d) => d.name === "title")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageWithTitle> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageWithTitle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc, title });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, title, data];
}
var ImageWithTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { data: 2 }, add_css8);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageWithTitle",
      options,
      id: create_fragment8.name
    });
  }
  get data() {
    throw new Error("<ImageWithTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageWithTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageWithTitle_default = ImageWithTitle;

// node_modules/taleem-pivot-player/slides/Table.svelte
var file9 = "node_modules/taleem-pivot-player/slides/Table.svelte";
function add_css9(target) {
  append_styles(target, "svelte-ovl28n", ".table-slide.svelte-ovl28n{display:flex;justify-content:center;align-items:center;height:100vh;padding:2rem;box-sizing:border-box}table.svelte-ovl28n{width:90%;border-collapse:collapse;font-size:2rem;box-shadow:0 0 10px rgba(0, 0, 0, 0.15)}th.svelte-ovl28n,td.svelte-ovl28n{padding:1rem 1.5rem;text-align:left;border:1px solid #ccc}th.svelte-ovl28n{background-color:#f0f0f0;font-weight:600}@media(max-width: 768px){table.svelte-ovl28n{font-size:1.4rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL1RhYmxlLnN2ZWx0ZSJdfQ== */");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  child_ctx[4] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let td;
  let t_value = (
    /*cell*/
    ctx[5] + ""
  );
  let t;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", "svelte-ovl28n");
      add_location(td, file9, 16, 14, 392);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(16:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let th;
  let t_value = (
    /*cell*/
    ctx[5] + ""
  );
  let t;
  const block = {
    c: function create() {
      th = element("th");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      t = claim_text(th_nodes, t_value);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", "svelte-ovl28n");
      add_location(th, file9, 14, 14, 342);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(14:12) {#if i === 0}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*i*/
      ctx2[4] === 0
    ) return create_if_block4;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(13:10) {#each row as cell}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let tr;
  let t;
  let each_value_1 = ensure_array_like_dev(
    /*row*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file9, 11, 8, 267);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tableData*/
      1) {
        each_value_1 = ensure_array_like_dev(
          /*row*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(11:6) {#each tableData as row, i}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let div;
  let table;
  let each_value = ensure_array_like_dev(
    /*tableData*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(table_nodes);
      }
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(table, "class", "svelte-ovl28n");
      add_location(table, file9, 9, 4, 217);
      attr_dev(div, "class", "table-slide svelte-ovl28n");
      add_location(div, file9, 8, 2, 187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(table, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*tableData*/
      1) {
        each_value = ensure_array_like_dev(
          /*tableData*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  let { data } = $$props;
  const tableData = ((_a = data.find((d) => d.name === "table")) == null ? void 0 : _a.content) ?? [];
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Table> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Table> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, tableData });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [tableData, data];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { data: 1 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment9.name
    });
  }
  get data() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/taleem-pivot-player/slides/StatisticSlide.svelte
var file10 = "node_modules/taleem-pivot-player/slides/StatisticSlide.svelte";
function add_css10(target) {
  append_styles(target, "svelte-x6jlyi", ".stat-slide.svelte-x6jlyi{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;width:100vw;text-align:center;gap:1rem}.stat-number.svelte-x6jlyi{font-size:10rem;font-weight:800;color:#333}.stat-label.svelte-x6jlyi{font-size:3rem;font-weight:500;color:#555}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhdGlzdGljU2xpZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL1N0YXRpc3RpY1NsaWRlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment10(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*number*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*number*/
        ctx[0]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*label*/
        ctx[1]
      );
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "stat-number svelte-x6jlyi");
      add_location(div0, file10, 8, 4, 219);
      attr_dev(div1, "class", "stat-label svelte-x6jlyi");
      add_location(div1, file10, 9, 4, 263);
      attr_dev(div2, "class", "stat-slide svelte-x6jlyi");
      add_location(div2, file10, 7, 2, 190);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StatisticSlide", slots, []);
  let { data } = $$props;
  const number = ((_a = data.find((d) => d.name === "number")) == null ? void 0 : _a.content) ?? "";
  const label = ((_b = data.find((d) => d.name === "label")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<StatisticSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<StatisticSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, number, label });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [number, label, data];
}
var StatisticSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { data: 2 }, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StatisticSlide",
      options,
      id: create_fragment10.name
    });
  }
  get data() {
    throw new Error("<StatisticSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<StatisticSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StatisticSlide_default = StatisticSlide;

// node_modules/taleem-pivot-player/slides/BarChartSlide.svelte
var file11 = "node_modules/taleem-pivot-player/slides/BarChartSlide.svelte";
function add_css11(target) {
  append_styles(target, "svelte-1oq83yb", ".slide-container.svelte-1oq83yb{display:flex;justify-content:center;align-items:center;height:100%;width:100%;padding:60px;box-sizing:border-box}.bar-container.svelte-1oq83yb{display:flex;flex-direction:column;align-items:center;width:60px;height:100%;justify-content:flex-end}.chart-area.svelte-1oq83yb{display:flex;align-items:flex-end;gap:100px;height:80%;width:100%;justify-content:center}.bar.svelte-1oq83yb{width:100%;transition:height 0.3s ease-in-out}.label.svelte-1oq83yb{margin-top:12px;font-size:1.5rem;color:black;text-align:center}@media(max-width: 768px){.label.svelte-1oq83yb{font-size:1rem}.bar-container.svelte-1oq83yb{width:40px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFyQ2hhcnRTbGlkZS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zbGlkZXMvQmFyQ2hhcnRTbGlkZS5zdmVsdGUiXX0= */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block6(ctx) {
  let div2;
  let div0;
  let t0;
  let div1;
  let t1_value = (
    /*bar*/
    ctx[3].label + ""
  );
  let t1;
  let t2;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = text(t1_value);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t1 = claim_text(div1_nodes, t1_value);
      div1_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "bar svelte-1oq83yb");
      set_style(
        div0,
        "height",
        /*bar*/
        ctx[3].value + "%"
      );
      set_style(
        div0,
        "background-color",
        /*bar*/
        ctx[3].color || "#3498db"
      );
      add_location(div0, file11, 22, 8, 594);
      attr_dev(div1, "class", "label svelte-1oq83yb");
      add_location(div1, file11, 26, 8, 728);
      attr_dev(div2, "class", "bar-container svelte-1oq83yb");
      add_location(div2, file11, 21, 6, 558);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div2, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*bars*/
      1) {
        set_style(
          div0,
          "height",
          /*bar*/
          ctx2[3].value + "%"
        );
      }
      if (dirty & /*bars*/
      1) {
        set_style(
          div0,
          "background-color",
          /*bar*/
          ctx2[3].color || "#3498db"
        );
      }
      if (dirty & /*bars*/
      1 && t1_value !== (t1_value = /*bar*/
      ctx2[3].label + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(21:4) {#each bars as bar}",
    ctx
  });
  return block;
}
function create_fragment11(ctx) {
  let div1;
  let div0;
  let each_value = ensure_array_like_dev(
    /*bars*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "chart-area svelte-1oq83yb");
      add_location(div0, file11, 19, 2, 503);
      attr_dev(div1, "class", "slide-container svelte-1oq83yb");
      add_location(div1, file11, 18, 0, 471);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*bars*/
      1) {
        each_value = ensure_array_like_dev(
          /*bars*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChartSlide", slots, []);
  let { data } = $$props;
  let { currentTime } = $$props;
  let bars = [];
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BarChartSlide> was created without expected prop 'data'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<BarChartSlide> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["data", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BarChartSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(2, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({ data, currentTime, bars });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(2, currentTime = $$props2.currentTime);
    if ("bars" in $$props2) $$invalidate(0, bars = $$props2.bars);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data, currentTime*/
    6) {
      $: $$invalidate(0, bars = data.filter((item) => item.name === "bar" && item.showAt <= currentTime).sort((a, b) => a.showAt - b.showAt));
    }
  };
  return [bars, data, currentTime];
}
var BarChartSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { data: 1, currentTime: 2 }, add_css11);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChartSlide",
      options,
      id: create_fragment11.name
    });
  }
  get data() {
    throw new Error("<BarChartSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarChartSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<BarChartSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<BarChartSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChartSlide_default = BarChartSlide;

// node_modules/taleem-pivot-player/slides/TwoColumnTextSlide.svelte
var file12 = "node_modules/taleem-pivot-player/slides/TwoColumnTextSlide.svelte";
function add_css12(target) {
  append_styles(target, "svelte-1omz5t3", ".two-col-slide.svelte-1omz5t3{height:100vh;width:100vw;padding:4rem;box-sizing:border-box;display:flex;flex-direction:column;gap:3rem}.slide-title.svelte-1omz5t3{font-size:4rem;padding-top:4rem;text-align:center;font-weight:bold}.columns.svelte-1omz5t3{display:flex;padding-left:20rem;gap:4rem;flex:1}.column.svelte-1omz5t3{flex:1;font-size:2.5rem;white-space:pre-line;line-height:1.7}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHdvQ29sdW1uVGV4dFNsaWRlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NsaWRlcy9Ud29Db2x1bW5UZXh0U2xpZGUuc3ZlbHRlIl19 */");
}
function create_if_block5(ctx) {
  let h1;
  let t;
  const block = {
    c: function create() {
      h1 = element("h1");
      t = text(
        /*title*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      h1 = claim_element(nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t = claim_text(
        h1_nodes,
        /*title*/
        ctx[2]
      );
      h1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "slide-title svelte-1omz5t3");
      add_location(h1, file12, 11, 4, 383);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h1, anchor);
      append_hydration_dev(h1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      4) set_data_dev(
        t,
        /*title*/
        ctx2[2]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(11:2) {#if title}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let div3;
  let t0;
  let div2;
  let div0;
  let t1;
  let t2;
  let div1;
  let t3;
  let if_block = (
    /*title*/
    ctx[2] && create_if_block5(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      div2 = element("div");
      div0 = element("div");
      t1 = text(
        /*left*/
        ctx[1]
      );
      t2 = space();
      div1 = element("div");
      t3 = text(
        /*right*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      if (if_block) if_block.l(div3_nodes);
      t0 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(
        div0_nodes,
        /*left*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      t2 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t3 = claim_text(
        div1_nodes,
        /*right*/
        ctx[0]
      );
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "column svelte-1omz5t3");
      add_location(div0, file12, 14, 4, 456);
      attr_dev(div1, "class", "column svelte-1omz5t3");
      add_location(div1, file12, 15, 4, 493);
      attr_dev(div2, "class", "columns svelte-1omz5t3");
      add_location(div2, file12, 13, 2, 430);
      attr_dev(div3, "class", "two-col-slide svelte-1omz5t3");
      add_location(div3, file12, 9, 0, 337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      if (if_block) if_block.m(div3, null);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t1);
      append_hydration_dev(div2, t2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t3);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          if_block.m(div3, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*left*/
      2) set_data_dev(
        t1,
        /*left*/
        ctx2[1]
      );
      if (dirty & /*right*/
      1) set_data_dev(
        t3,
        /*right*/
        ctx2[0]
      );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  let title;
  let left;
  let right;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TwoColumnTextSlide", slots, []);
  let { data } = $$props;
  let { currentTime } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<TwoColumnTextSlide> was created without expected prop 'data'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<TwoColumnTextSlide> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["data", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TwoColumnTextSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(4, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({ data, currentTime, right, left, title });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(4, currentTime = $$props2.currentTime);
    if ("right" in $$props2) $$invalidate(0, right = $$props2.right);
    if ("left" in $$props2) $$invalidate(1, left = $$props2.left);
    if ("title" in $$props2) $$invalidate(2, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b, _c;
    if ($$self.$$.dirty & /*data, currentTime*/
    24) {
      $: $$invalidate(2, title = ((_a = data.find((d) => d.name === "title" && d.showAt <= currentTime)) == null ? void 0 : _a.content) ?? "");
    }
    if ($$self.$$.dirty & /*data, currentTime*/
    24) {
      $: $$invalidate(1, left = ((_b = data.find((d) => d.name === "left" && d.showAt <= currentTime)) == null ? void 0 : _b.content) ?? "");
    }
    if ($$self.$$.dirty & /*data, currentTime*/
    24) {
      $: $$invalidate(0, right = ((_c = data.find((d) => d.name === "right" && d.showAt <= currentTime)) == null ? void 0 : _c.content) ?? "");
    }
  };
  return [right, left, title, data, currentTime];
}
var TwoColumnTextSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { data: 3, currentTime: 4 }, add_css12);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TwoColumnTextSlide",
      options,
      id: create_fragment12.name
    });
  }
  get data() {
    throw new Error("<TwoColumnTextSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<TwoColumnTextSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<TwoColumnTextSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<TwoColumnTextSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TwoColumnTextSlide_default = TwoColumnTextSlide;

// node_modules/taleem-pivot-player/slides/DonutChartSlide.svelte
var file13 = "node_modules/taleem-pivot-player/slides/DonutChartSlide.svelte";
function add_css13(target) {
  append_styles(target, "svelte-180u8c1", ".donut-slide.svelte-180u8c1{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;gap:2rem}svg.svelte-180u8c1{transform:rotate(-90deg)}.track.svelte-180u8c1{fill:none;stroke:#eee;stroke-width:20}.fill.svelte-180u8c1{fill:none;stroke-width:20;stroke-linecap:round;transition:stroke-dashoffset 1s ease}.center-text.svelte-180u8c1{fill:#333;font-size:2.5rem;font-weight:bold;transform:rotate(90deg)}.donut-label.svelte-180u8c1{font-size:2.5rem;font-weight:500}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9udXRDaGFydFNsaWRlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NsaWRlcy9Eb251dENoYXJ0U2xpZGUuc3ZlbHRlIl19 */");
}
function create_fragment13(ctx) {
  let div1;
  let svg;
  let circle0;
  let circle1;
  let text_1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  const block = {
    c: function create() {
      div1 = element("div");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      text_1 = svg_element("text");
      t0 = text(
        /*percent*/
        ctx[0]
      );
      t1 = text("%");
      t2 = space();
      div0 = element("div");
      t3 = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      svg = claim_svg_element(div1_nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { class: true, cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        cx: true,
        cy: true,
        r: true,
        stroke: true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true
      });
      children(circle1).forEach(detach_dev);
      text_1 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t0 = claim_text(
        text_1_nodes,
        /*percent*/
        ctx[0]
      );
      t1 = claim_text(text_1_nodes, "%");
      text_1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t3 = claim_text(
        div0_nodes,
        /*label*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "class", "track svelte-180u8c1");
      attr_dev(circle0, "cx", "100");
      attr_dev(circle0, "cy", "100");
      attr_dev(circle0, "r", "80");
      add_location(circle0, file13, 13, 6, 469);
      attr_dev(circle1, "class", "fill svelte-180u8c1");
      attr_dev(circle1, "cx", "100");
      attr_dev(circle1, "cy", "100");
      attr_dev(circle1, "r", "80");
      attr_dev(
        circle1,
        "stroke",
        /*color*/
        ctx[2]
      );
      attr_dev(
        circle1,
        "stroke-dasharray",
        /*circumference*/
        ctx[3]
      );
      attr_dev(
        circle1,
        "stroke-dashoffset",
        /*offset*/
        ctx[4]
      );
      add_location(circle1, file13, 14, 6, 525);
      attr_dev(text_1, "x", "100");
      attr_dev(text_1, "y", "110");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "class", "center-text svelte-180u8c1");
      add_location(text_1, file13, 23, 6, 717);
      attr_dev(svg, "width", "200");
      attr_dev(svg, "height", "200");
      attr_dev(svg, "viewBox", "0 0 200 200");
      attr_dev(svg, "class", "svelte-180u8c1");
      add_location(svg, file13, 12, 4, 410);
      attr_dev(div0, "class", "donut-label svelte-180u8c1");
      add_location(div0, file13, 25, 4, 813);
      attr_dev(div1, "class", "donut-slide svelte-180u8c1");
      add_location(div1, file13, 11, 2, 380);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, svg);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, text_1);
      append_hydration_dev(text_1, t0);
      append_hydration_dev(text_1, t1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t3);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DonutChartSlide", slots, []);
  let { data } = $$props;
  const percent = parseInt(((_a = data.find((d) => d.name === "percent")) == null ? void 0 : _a.content) ?? 0);
  const label = ((_b = data.find((d) => d.name === "label")) == null ? void 0 : _b.content) ?? "";
  const color = ((_c = data.find((d) => d.name === "color")) == null ? void 0 : _c.content) ?? "#4CAF50";
  const circumference = 2 * Math.PI * 80;
  const offset = circumference * (1 - percent / 100);
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<DonutChartSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DonutChartSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(5, data = $$props2.data);
  };
  $$self.$capture_state = () => ({
    data,
    percent,
    label,
    color,
    circumference,
    offset
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(5, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [percent, label, color, circumference, offset, data];
}
var DonutChartSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { data: 5 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DonutChartSlide",
      options,
      id: create_fragment13.name
    });
  }
  get data() {
    throw new Error("<DonutChartSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<DonutChartSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DonutChartSlide_default = DonutChartSlide;

// node_modules/taleem-pivot-player/slides/TitleAndSubtitle.svelte
var file14 = "node_modules/taleem-pivot-player/slides/TitleAndSubtitle.svelte";
function add_css14(target) {
  append_styles(target, "svelte-1cpjjwr", ".slide-container.svelte-1cpjjwr{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;width:100%;padding:40px;box-sizing:border-box;text-align:center;gap:20px}.slide-title.svelte-1cpjjwr{font-size:3rem;margin:0}.slide-subtitle.svelte-1cpjjwr{font-size:1.5rem;margin:0;opacity:0.8}@media(max-width: 768px){.slide-title.svelte-1cpjjwr{font-size:2rem}.slide-subtitle.svelte-1cpjjwr{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGl0bGVBbmRTdWJ0aXRsZS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zbGlkZXMvVGl0bGVBbmRTdWJ0aXRsZS5zdmVsdGUiXX0= */");
}
function create_if_block_1(ctx) {
  let h1;
  let t;
  const block = {
    c: function create() {
      h1 = element("h1");
      t = text(
        /*title*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      h1 = claim_element(nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t = claim_text(
        h1_nodes,
        /*title*/
        ctx[1]
      );
      h1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "slide-title svelte-1cpjjwr");
      add_location(h1, file14, 10, 4, 302);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h1, anchor);
      append_hydration_dev(h1, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*title*/
      2) set_data_dev(
        t,
        /*title*/
        ctx2[1]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(10:2) {#if title}",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(
        /*subtitle*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { class: true });
      var p_nodes = children(p);
      t = claim_text(
        p_nodes,
        /*subtitle*/
        ctx[0]
      );
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "slide-subtitle svelte-1cpjjwr");
      add_location(p, file14, 13, 4, 368);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*subtitle*/
      1) set_data_dev(
        t,
        /*subtitle*/
        ctx2[0]
      );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(13:2) {#if subtitle}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div;
  let t;
  let if_block0 = (
    /*title*/
    ctx[1] && create_if_block_1(ctx)
  );
  let if_block1 = (
    /*subtitle*/
    ctx[0] && create_if_block6(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t = space();
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      if (if_block1) if_block1.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "slide-container svelte-1cpjjwr");
      add_location(div, file14, 8, 0, 254);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t);
      if (if_block1) if_block1.m(div, null);
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*title*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*subtitle*/
        ctx2[0]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block6(ctx2);
          if_block1.c();
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let title;
  let subtitle;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TitleAndSubtitle", slots, []);
  let { data } = $$props;
  let { currentTime } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<TitleAndSubtitle> was created without expected prop 'data'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<TitleAndSubtitle> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["data", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TitleAndSubtitle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(3, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({ data, currentTime, subtitle, title });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(3, currentTime = $$props2.currentTime);
    if ("subtitle" in $$props2) $$invalidate(0, subtitle = $$props2.subtitle);
    if ("title" in $$props2) $$invalidate(1, title = $$props2.title);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    var _a, _b;
    if ($$self.$$.dirty & /*data, currentTime*/
    12) {
      $: $$invalidate(1, title = ((_a = data.find((d) => d.name === "title" && d.showAt <= currentTime)) == null ? void 0 : _a.content) ?? "");
    }
    if ($$self.$$.dirty & /*data, currentTime*/
    12) {
      $: $$invalidate(0, subtitle = ((_b = data.find((d) => d.name === "subtitle" && d.showAt <= currentTime)) == null ? void 0 : _b.content) ?? "");
    }
  };
  return [subtitle, title, data, currentTime];
}
var TitleAndSubtitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { data: 2, currentTime: 3 }, add_css14);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TitleAndSubtitle",
      options,
      id: create_fragment14.name
    });
  }
  get data() {
    throw new Error("<TitleAndSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<TitleAndSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<TitleAndSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<TitleAndSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TitleAndSubtitle_default = TitleAndSubtitle;

// node_modules/taleem-pivot-player/slides/BulletList.svelte
var file15 = "node_modules/taleem-pivot-player/slides/BulletList.svelte";
function add_css15(target) {
  append_styles(target, "svelte-f6eswv", ".slide-container.svelte-f6eswv{display:flex;justify-content:center;align-items:center;height:100%;width:100%;padding:40px;box-sizing:border-box}.bullet-list.svelte-f6eswv{list-style-type:disc;padding-left:1.5rem;font-size:5rem}.bullet-item.svelte-f6eswv{margin-bottom:0.8rem}@media(max-width: 768px){.bullet-list.svelte-f6eswv{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnVsbGV0TGlzdC5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zbGlkZXMvQnVsbGV0TGlzdC5zdmVsdGUiXX0= */");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block7(ctx) {
  let li;
  let t_value = (
    /*bullet*/
    ctx[3] + ""
  );
  let t;
  const block = {
    c: function create() {
      li = element("li");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t = claim_text(li_nodes, t_value);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "bullet-item svelte-f6eswv");
      add_location(li, file15, 14, 6, 403);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*visibleBullets*/
      1 && t_value !== (t_value = /*bullet*/
      ctx2[3] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(14:4) {#each visibleBullets as bullet}",
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let div;
  let ul;
  let each_value = ensure_array_like_dev(
    /*visibleBullets*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "bullet-list svelte-f6eswv");
      add_location(ul, file15, 12, 2, 335);
      attr_dev(div, "class", "slide-container svelte-f6eswv");
      add_location(div, file15, 11, 0, 303);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*visibleBullets*/
      1) {
        each_value = ensure_array_like_dev(
          /*visibleBullets*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  let visibleBullets;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BulletList", slots, []);
  let { data } = $$props;
  let { currentTime } = $$props;
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BulletList> was created without expected prop 'data'");
    }
    if (currentTime === void 0 && !("currentTime" in $$props || $$self.$$.bound[$$self.$$.props["currentTime"]])) {
      console.warn("<BulletList> was created without expected prop 'currentTime'");
    }
  });
  const writable_props = ["data", "currentTime"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BulletList> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(2, currentTime = $$props2.currentTime);
  };
  $$self.$capture_state = () => ({ data, currentTime, visibleBullets });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
    if ("currentTime" in $$props2) $$invalidate(2, currentTime = $$props2.currentTime);
    if ("visibleBullets" in $$props2) $$invalidate(0, visibleBullets = $$props2.visibleBullets);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*data, currentTime*/
    6) {
      $: $$invalidate(0, visibleBullets = data.filter((item) => item.name === "bullet" && item.showAt <= currentTime).sort((a, b) => a.showAt - b.showAt).map((item) => item.content));
    }
  };
  return [visibleBullets, data, currentTime];
}
var BulletList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { data: 1, currentTime: 2 }, add_css15);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BulletList",
      options,
      id: create_fragment15.name
    });
  }
  get data() {
    throw new Error("<BulletList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BulletList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get currentTime() {
    throw new Error("<BulletList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<BulletList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BulletList_default = BulletList;

// node_modules/taleem-pivot-player/slides/BigNumber.svelte
var file16 = "node_modules/taleem-pivot-player/slides/BigNumber.svelte";
function add_css16(target) {
  append_styles(target, "svelte-hzv82f", ".slide-container.svelte-hzv82f{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;width:100%;gap:20px;padding:40px;box-sizing:border-box;text-align:center}.big-number.svelte-hzv82f{font-size:6rem;font-weight:bold}.label-text.svelte-hzv82f{font-size:1.5rem;opacity:0.8}@media(max-width: 768px){.big-number.svelte-hzv82f{font-size:3rem}.label-text.svelte-hzv82f{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmlnTnVtYmVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NsaWRlcy9CaWdOdW1iZXIuc3ZlbHRlIl19 */");
}
function create_fragment16(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*number*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*number*/
        ctx[0]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*label*/
        ctx[1]
      );
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "big-number svelte-hzv82f");
      add_location(div0, file16, 8, 4, 224);
      attr_dev(div1, "class", "label-text svelte-hzv82f");
      add_location(div1, file16, 9, 4, 267);
      attr_dev(div2, "class", "slide-container svelte-hzv82f");
      add_location(div2, file16, 7, 2, 190);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BigNumber", slots, []);
  let { data } = $$props;
  const number = ((_a = data.find((d) => d.name === "number")) == null ? void 0 : _a.content) ?? "";
  const label = ((_b = data.find((d) => d.name === "label")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BigNumber> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BigNumber> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, number, label });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [number, label, data];
}
var BigNumber = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { data: 2 }, add_css16);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BigNumber",
      options,
      id: create_fragment16.name
    });
  }
  get data() {
    throw new Error("<BigNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BigNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BigNumber_default = BigNumber;

// node_modules/taleem-pivot-player/slides/QuoteWithImage.svelte
var file17 = "node_modules/taleem-pivot-player/slides/QuoteWithImage.svelte";
function add_css17(target) {
  append_styles(target, "svelte-1s00uxy", ".slide-container.svelte-1s00uxy.svelte-1s00uxy{display:flex;flex-direction:column;align-items:center;text-align:center;gap:20px;height:100%;width:100%;padding:40px;box-sizing:border-box}.quote.svelte-1s00uxy.svelte-1s00uxy{font-size:2rem;font-style:italic;margin:0}.author.svelte-1s00uxy.svelte-1s00uxy{margin-top:10px;font-size:1.2rem;opacity:0.7}.image-zone.svelte-1s00uxy img.svelte-1s00uxy{max-width:120px;height:auto;border-radius:50%}@media(max-width: 768px){.quote.svelte-1s00uxy.svelte-1s00uxy{font-size:1.5rem}.author.svelte-1s00uxy.svelte-1s00uxy{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVvdGVXaXRoSW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc2xpZGVzL1F1b3RlV2l0aEltYWdlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment17(ctx) {
  let div3;
  let div1;
  let blockquote;
  let t0;
  let t1;
  let t2;
  let t3;
  let div0;
  let t4;
  let t5;
  let t6;
  let div2;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div3 = element("div");
      div1 = element("div");
      blockquote = element("blockquote");
      t0 = text('"');
      t1 = text(
        /*quote*/
        ctx[0]
      );
      t2 = text('"');
      t3 = space();
      div0 = element("div");
      t4 = text("— ");
      t5 = text(
        /*author*/
        ctx[1]
      );
      t6 = space();
      div2 = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      blockquote = claim_element(div1_nodes, "BLOCKQUOTE", { class: true });
      var blockquote_nodes = children(blockquote);
      t0 = claim_text(blockquote_nodes, '"');
      t1 = claim_text(
        blockquote_nodes,
        /*quote*/
        ctx[0]
      );
      t2 = claim_text(blockquote_nodes, '"');
      blockquote_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t4 = claim_text(div0_nodes, "— ");
      t5 = claim_text(
        div0_nodes,
        /*author*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t6 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      img = claim_element(div2_nodes, "IMG", { src: true, alt: true, class: true });
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(blockquote, "class", "quote svelte-1s00uxy");
      add_location(blockquote, file17, 10, 6, 327);
      attr_dev(div0, "class", "author svelte-1s00uxy");
      add_location(div0, file17, 11, 6, 382);
      attr_dev(div1, "class", "quote-zone");
      add_location(div1, file17, 9, 4, 296);
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[2])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Author Image");
      attr_dev(img, "class", "svelte-1s00uxy");
      add_location(img, file17, 14, 6, 465);
      attr_dev(div2, "class", "image-zone svelte-1s00uxy");
      add_location(div2, file17, 13, 4, 434);
      attr_dev(div3, "class", "slide-container svelte-1s00uxy");
      add_location(div3, file17, 8, 2, 262);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, blockquote);
      append_hydration_dev(blockquote, t0);
      append_hydration_dev(blockquote, t1);
      append_hydration_dev(blockquote, t2);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t4);
      append_hydration_dev(div0, t5);
      append_hydration_dev(div3, t6);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QuoteWithImage", slots, []);
  let { data } = $$props;
  const quote = ((_a = data.find((d) => d.name === "quote")) == null ? void 0 : _a.content) ?? "";
  const author = ((_b = data.find((d) => d.name === "author")) == null ? void 0 : _b.content) ?? "";
  const imageSrc = ((_c = data.find((d) => d.name === "image")) == null ? void 0 : _c.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<QuoteWithImage> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<QuoteWithImage> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, quote, author, imageSrc });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [quote, author, imageSrc, data];
}
var QuoteWithImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { data: 3 }, add_css17);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QuoteWithImage",
      options,
      id: create_fragment17.name
    });
  }
  get data() {
    throw new Error("<QuoteWithImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<QuoteWithImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QuoteWithImage_default = QuoteWithImage;

// node_modules/taleem-pivot-player/slides/ContactSlide.svelte
var file18 = "node_modules/taleem-pivot-player/slides/ContactSlide.svelte";
function add_css18(target) {
  append_styles(target, "svelte-q5d75h", ".slide-container.svelte-q5d75h{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;width:100%;text-align:center;gap:12px;padding:40px;box-sizing:border-box}.headline.svelte-q5d75h{font-size:2.5rem;margin:0 0 10px 0}.contact-line.svelte-q5d75h{font-size:1.2rem;margin:0}@media(max-width: 768px){.headline.svelte-q5d75h{font-size:1.6rem}.contact-line.svelte-q5d75h{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGFjdFNsaWRlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NsaWRlcy9Db250YWN0U2xpZGUuc3ZlbHRlIl19 */");
}
function create_fragment18(ctx) {
  let div;
  let h1;
  let t0;
  let t1;
  let p0;
  let t2;
  let t3;
  let t4;
  let p1;
  let t5;
  let t6;
  const block = {
    c: function create() {
      div = element("div");
      h1 = element("h1");
      t0 = text(
        /*headline*/
        ctx[0]
      );
      t1 = space();
      p0 = element("p");
      t2 = text("Email: ");
      t3 = text(
        /*email*/
        ctx[1]
      );
      t4 = space();
      p1 = element("p");
      t5 = text("Phone: ");
      t6 = text(
        /*phone*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h1 = claim_element(div_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*headline*/
        ctx[0]
      );
      h1_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      p0 = claim_element(div_nodes, "P", { class: true });
      var p0_nodes = children(p0);
      t2 = claim_text(p0_nodes, "Email: ");
      t3 = claim_text(
        p0_nodes,
        /*email*/
        ctx[1]
      );
      p0_nodes.forEach(detach_dev);
      t4 = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", { class: true });
      var p1_nodes = children(p1);
      t5 = claim_text(p1_nodes, "Phone: ");
      t6 = claim_text(
        p1_nodes,
        /*phone*/
        ctx[2]
      );
      p1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "headline svelte-q5d75h");
      add_location(h1, file18, 9, 4, 297);
      attr_dev(p0, "class", "contact-line svelte-q5d75h");
      add_location(p0, file18, 10, 4, 338);
      attr_dev(p1, "class", "contact-line svelte-q5d75h");
      add_location(p1, file18, 11, 4, 385);
      attr_dev(div, "class", "slide-container svelte-q5d75h");
      add_location(div, file18, 8, 2, 263);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, p0);
      append_hydration_dev(p0, t2);
      append_hydration_dev(p0, t3);
      append_hydration_dev(div, t4);
      append_hydration_dev(div, p1);
      append_hydration_dev(p1, t5);
      append_hydration_dev(p1, t6);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContactSlide", slots, []);
  let { data } = $$props;
  const headline = ((_a = data.find((d) => d.name === "headline")) == null ? void 0 : _a.content) ?? "";
  const email = ((_b = data.find((d) => d.name === "email")) == null ? void 0 : _b.content) ?? "";
  const phone = ((_c = data.find((d) => d.name === "phone")) == null ? void 0 : _c.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ContactSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContactSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, headline, email, phone });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [headline, email, phone, data];
}
var ContactSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { data: 3 }, add_css18);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContactSlide",
      options,
      id: create_fragment18.name
    });
  }
  get data() {
    throw new Error("<ContactSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ContactSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContactSlide_default = ContactSlide;

// node_modules/taleem-pivot-player/SlideMap.js
var SlideMap_default = {
  quoteSlide: Quote_default,
  cornerWordsSlide: CornerWords_default,
  titleSlide: Title_default,
  imageSlide: Image_default,
  imageLeftBulletsRight: ImageLeftBulletsRight_default,
  imageRightBulletsLeft: ImageRightBulletsLeft_default,
  imageWithCaption: ImageWithCaption_default,
  imageWithTitle: ImageWithTitle_default,
  table: Table_default,
  statistic: StatisticSlide_default,
  barChart: BarChartSlide_default,
  twoColumnText: TwoColumnTextSlide_default,
  donutChart: DonutChartSlide_default,
  titleAndSubtitle: TitleAndSubtitle_default,
  bulletList: BulletList_default,
  bigNumber: BigNumber_default,
  quoteWithImage: QuoteWithImage_default,
  contactSlide: ContactSlide_default
};

// node_modules/taleem-pivot-player/NavBar.svelte
var file19 = "node_modules/taleem-pivot-player/NavBar.svelte";
function add_css19(target) {
  append_styles(target, "svelte-1pmsr9x", '.nav-bar.svelte-1pmsr9x.svelte-1pmsr9x{position:absolute;bottom:0;left:0;right:0;background:rgba(0, 0, 0, 0.6);color:white;display:flex;align-items:center;padding:0.5rem 1rem;gap:0.5rem;opacity:0;transition:opacity 0.4s;z-index:10}.nav-bar.visible.svelte-1pmsr9x.svelte-1pmsr9x{opacity:1}.nav-bar.svelte-1pmsr9x button.svelte-1pmsr9x{border:none;border-radius:6px;padding:0.4rem 0.75rem;font-size:0.9rem;background:#333;color:#fff;cursor:pointer}.nav-bar.svelte-1pmsr9x button.svelte-1pmsr9x:hover{background:#555}.nav-bar.svelte-1pmsr9x .timer.svelte-1pmsr9x{min-width:90px;text-align:center}.nav-bar.svelte-1pmsr9x input[type="range"].svelte-1pmsr9x{flex:1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmF2QmFyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL05hdkJhci5zdmVsdGUiXX0= */');
}
function create_fragment19(ctx) {
  let div;
  let button0;
  let textContent = "←";
  let t1;
  let button1;
  let textContent_1 = "▶️";
  let t3;
  let button2;
  let textContent_2 = "⏸️";
  let t5;
  let button3;
  let textContent_3 = "⏹️";
  let t7;
  let span;
  let t8_value = formatTime(
    /*currentTime*/
    ctx[0]
  ) + "";
  let t8;
  let t9;
  let t10_value = formatTime(
    /*duration*/
    ctx[1]
  ) + "";
  let t10;
  let t11;
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      button0 = element("button");
      button0.textContent = textContent;
      t1 = space();
      button1 = element("button");
      button1.textContent = textContent_1;
      t3 = space();
      button2 = element("button");
      button2.textContent = textContent_2;
      t5 = space();
      button3 = element("button");
      button3.textContent = textContent_3;
      t7 = space();
      span = element("span");
      t8 = text(t8_value);
      t9 = text(" / ");
      t10 = text(t10_value);
      t11 = space();
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      button0 = claim_element(div_nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button0) !== "svelte-1nfrdxu") button0.textContent = textContent;
      t1 = claim_space(div_nodes);
      button1 = claim_element(div_nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button1) !== "svelte-1q3xxgy") button1.textContent = textContent_1;
      t3 = claim_space(div_nodes);
      button2 = claim_element(div_nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button2) !== "svelte-5l3erq") button2.textContent = textContent_2;
      t5 = claim_space(div_nodes);
      button3 = claim_element(div_nodes, "BUTTON", { class: true, ["data-svelte-h"]: true });
      if (get_svelte_dataset(button3) !== "svelte-so5a2d") button3.textContent = textContent_3;
      t7 = claim_space(div_nodes);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t8 = claim_text(span_nodes, t8_value);
      t9 = claim_text(span_nodes, " / ");
      t10 = claim_text(span_nodes, t10_value);
      span_nodes.forEach(detach_dev);
      t11 = claim_space(div_nodes);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        min: true,
        max: true,
        step: true,
        class: true
      });
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button0, "class", "svelte-1pmsr9x");
      add_location(button0, file19, 39, 2, 867);
      attr_dev(button1, "class", "svelte-1pmsr9x");
      add_location(button1, file19, 40, 2, 906);
      attr_dev(button2, "class", "svelte-1pmsr9x");
      add_location(button2, file19, 41, 2, 947);
      attr_dev(button3, "class", "svelte-1pmsr9x");
      add_location(button3, file19, 42, 2, 988);
      attr_dev(span, "class", "timer svelte-1pmsr9x");
      add_location(span, file19, 44, 2, 1029);
      attr_dev(input, "type", "range");
      attr_dev(input, "min", "0");
      attr_dev(
        input,
        "max",
        /*duration*/
        ctx[1]
      );
      attr_dev(input, "step", "0.1");
      attr_dev(input, "class", "svelte-1pmsr9x");
      add_location(input, file19, 45, 2, 1109);
      attr_dev(div, "class", "nav-bar svelte-1pmsr9x");
      toggle_class(
        div,
        "visible",
        /*visible*/
        ctx[7]
      );
      add_location(div, file19, 33, 0, 765);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, button0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, button1);
      append_hydration_dev(div, t3);
      append_hydration_dev(div, button2);
      append_hydration_dev(div, t5);
      append_hydration_dev(div, button3);
      append_hydration_dev(div, t7);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t8);
      append_hydration_dev(span, t9);
      append_hydration_dev(span, t10);
      append_hydration_dev(div, t11);
      append_hydration_dev(div, input);
      set_input_value(
        input,
        /*currentTime*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            function() {
              if (is_function(
                /*onBack*/
                ctx[5]
              )) ctx[5].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            function() {
              if (is_function(
                /*onPlay*/
                ctx[2]
              )) ctx[2].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button2,
            "click",
            function() {
              if (is_function(
                /*onPause*/
                ctx[3]
              )) ctx[3].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button3,
            "click",
            function() {
              if (is_function(
                /*onStop*/
                ctx[4]
              )) ctx[4].apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "change",
            /*input_change_input_handler*/
            ctx[9]
          ),
          listen_dev(
            input,
            "input",
            /*input_change_input_handler*/
            ctx[9]
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "pointermove",
            /*handleMove*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "touchstart",
            /*handleMove*/
            ctx[8],
            { passive: true },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*currentTime*/
      1 && t8_value !== (t8_value = formatTime(
        /*currentTime*/
        ctx[0]
      ) + "")) set_data_dev(t8, t8_value);
      if (dirty & /*duration*/
      2 && t10_value !== (t10_value = formatTime(
        /*duration*/
        ctx[1]
      ) + "")) set_data_dev(t10, t10_value);
      if (dirty & /*duration*/
      2) {
        attr_dev(
          input,
          "max",
          /*duration*/
          ctx[1]
        );
      }
      if (dirty & /*currentTime*/
      1) {
        set_input_value(
          input,
          /*currentTime*/
          ctx[0]
        );
      }
      if (dirty & /*visible*/
      128) {
        toggle_class(
          div,
          "visible",
          /*visible*/
          ctx[7]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function formatTime(seconds) {
  const m = Math.floor(seconds / 60).toString().padStart(2, "0");
  const s = Math.floor(seconds % 60).toString().padStart(2, "0");
  return `${m}:${s}`;
}
function instance19($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NavBar", slots, []);
  let { currentTime = 0 } = $$props;
  let { duration = 100 } = $$props;
  let { onPlay = () => {
  } } = $$props;
  let { onPause = () => {
  } } = $$props;
  let { onStop = () => {
  } } = $$props;
  let { onBack = () => {
  } } = $$props;
  let { onSeek = (val) => {
  } } = $$props;
  let visible = true;
  let hideTimeout;
  function showTemporarily() {
    $$invalidate(7, visible = true);
    clearTimeout(hideTimeout);
    hideTimeout = setTimeout(() => $$invalidate(7, visible = false), 4e3);
  }
  const handleMove = () => showTemporarily();
  const writable_props = ["currentTime", "duration", "onPlay", "onPause", "onStop", "onBack", "onSeek"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<NavBar> was created with unknown prop '${key}'`);
  });
  function input_change_input_handler() {
    currentTime = to_number(this.value);
    $$invalidate(0, currentTime);
  }
  const input_handler = (e) => onSeek(+e.target.value);
  $$self.$$set = ($$props2) => {
    if ("currentTime" in $$props2) $$invalidate(0, currentTime = $$props2.currentTime);
    if ("duration" in $$props2) $$invalidate(1, duration = $$props2.duration);
    if ("onPlay" in $$props2) $$invalidate(2, onPlay = $$props2.onPlay);
    if ("onPause" in $$props2) $$invalidate(3, onPause = $$props2.onPause);
    if ("onStop" in $$props2) $$invalidate(4, onStop = $$props2.onStop);
    if ("onBack" in $$props2) $$invalidate(5, onBack = $$props2.onBack);
    if ("onSeek" in $$props2) $$invalidate(6, onSeek = $$props2.onSeek);
  };
  $$self.$capture_state = () => ({
    currentTime,
    duration,
    onPlay,
    onPause,
    onStop,
    onBack,
    onSeek,
    visible,
    hideTimeout,
    formatTime,
    showTemporarily,
    handleMove
  });
  $$self.$inject_state = ($$props2) => {
    if ("currentTime" in $$props2) $$invalidate(0, currentTime = $$props2.currentTime);
    if ("duration" in $$props2) $$invalidate(1, duration = $$props2.duration);
    if ("onPlay" in $$props2) $$invalidate(2, onPlay = $$props2.onPlay);
    if ("onPause" in $$props2) $$invalidate(3, onPause = $$props2.onPause);
    if ("onStop" in $$props2) $$invalidate(4, onStop = $$props2.onStop);
    if ("onBack" in $$props2) $$invalidate(5, onBack = $$props2.onBack);
    if ("onSeek" in $$props2) $$invalidate(6, onSeek = $$props2.onSeek);
    if ("visible" in $$props2) $$invalidate(7, visible = $$props2.visible);
    if ("hideTimeout" in $$props2) hideTimeout = $$props2.hideTimeout;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    currentTime,
    duration,
    onPlay,
    onPause,
    onStop,
    onBack,
    onSeek,
    visible,
    handleMove,
    input_change_input_handler,
    input_handler
  ];
}
var NavBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance19,
      create_fragment19,
      safe_not_equal,
      {
        currentTime: 0,
        duration: 1,
        onPlay: 2,
        onPause: 3,
        onStop: 4,
        onBack: 5,
        onSeek: 6
      },
      add_css19
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NavBar",
      options,
      id: create_fragment19.name
    });
  }
  get currentTime() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set currentTime(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get duration() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set duration(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPlay() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPlay(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onPause() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onPause(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onStop() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onStop(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onBack() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onBack(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get onSeek() {
    throw new Error("<NavBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set onSeek(value) {
    throw new Error("<NavBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NavBar_default = NavBar;

// node_modules/taleem-pivot-player/background/StaticBackground.svelte
var file20 = "node_modules/taleem-pivot-player/background/StaticBackground.svelte";
function create_if_block7(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "background-image", "url(" + /*backgroundImage*/
      ctx[1] + ")");
      set_style(div, "background-size", "cover");
      set_style(div, "background-position", "center");
      set_style(
        div,
        "opacity",
        /*backgroundImageOpacity*/
        ctx[2]
      );
      set_style(div, "position", "absolute");
      set_style(div, "top", "0");
      set_style(div, "left", "0");
      set_style(div, "width", "100%");
      set_style(div, "height", "100%");
      set_style(div, "z-index", "1");
      add_location(div, file20, 23, 4, 497);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*backgroundImage*/
      2) {
        set_style(div, "background-image", "url(" + /*backgroundImage*/
        ctx2[1] + ")");
      }
      if (dirty & /*backgroundImageOpacity*/
      4) {
        set_style(
          div,
          "opacity",
          /*backgroundImageOpacity*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(23:2) {#if backgroundImage}",
    ctx
  });
  return block;
}
function create_fragment20(ctx) {
  let div0;
  let t0;
  let t1;
  let div1;
  let if_block = (
    /*backgroundImage*/
    ctx[1] && create_if_block7(ctx)
  );
  const block = {
    c: function create() {
      div0 = element("div");
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { style: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      t1 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { style: true });
      children(div1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        div0,
        "background-color",
        /*backgroundColor*/
        ctx[0]
      );
      set_style(div0, "position", "absolute");
      set_style(div0, "top", "0");
      set_style(div0, "left", "0");
      set_style(div0, "width", "100%");
      set_style(div0, "height", "100%");
      set_style(div0, "z-index", "0");
      add_location(div0, file20, 9, 2, 252);
      set_style(div1, "background-image", "radial-gradient(rgba(255,255,255," + /*patternOpacity*/
      ctx[3] + ") 1px, transparent 1px)");
      set_style(
        div1,
        "background-size",
        /*patternSize*/
        ctx[4] + "px " + /*patternSize*/
        ctx[4] + "px"
      );
      set_style(div1, "position", "absolute");
      set_style(div1, "top", "0");
      set_style(div1, "left", "0");
      set_style(div1, "width", "100%");
      set_style(div1, "height", "100%");
      set_style(div1, "z-index", "2");
      set_style(div1, "pointer-events", "none");
      add_location(div1, file20, 40, 2, 863);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div1, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*backgroundColor*/
      1) {
        set_style(
          div0,
          "background-color",
          /*backgroundColor*/
          ctx2[0]
        );
      }
      if (
        /*backgroundImage*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*patternOpacity*/
      8) {
        set_style(div1, "background-image", "radial-gradient(rgba(255,255,255," + /*patternOpacity*/
        ctx2[3] + ") 1px, transparent 1px)");
      }
      if (dirty & /*patternSize*/
      16) {
        set_style(
          div1,
          "background-size",
          /*patternSize*/
          ctx2[4] + "px " + /*patternSize*/
          ctx2[4] + "px"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(div1);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StaticBackground", slots, []);
  let { backgroundColor = "#0e490f" } = $$props;
  let { backgroundImage = null } = $$props;
  let { backgroundImageOpacity = 0.07 } = $$props;
  let { patternOpacity = 0.25 } = $$props;
  let { patternSize = 28 } = $$props;
  const writable_props = [
    "backgroundColor",
    "backgroundImage",
    "backgroundImageOpacity",
    "patternOpacity",
    "patternSize"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<StaticBackground> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("backgroundColor" in $$props2) $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("backgroundImage" in $$props2) $$invalidate(1, backgroundImage = $$props2.backgroundImage);
    if ("backgroundImageOpacity" in $$props2) $$invalidate(2, backgroundImageOpacity = $$props2.backgroundImageOpacity);
    if ("patternOpacity" in $$props2) $$invalidate(3, patternOpacity = $$props2.patternOpacity);
    if ("patternSize" in $$props2) $$invalidate(4, patternSize = $$props2.patternSize);
  };
  $$self.$capture_state = () => ({
    backgroundColor,
    backgroundImage,
    backgroundImageOpacity,
    patternOpacity,
    patternSize
  });
  $$self.$inject_state = ($$props2) => {
    if ("backgroundColor" in $$props2) $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("backgroundImage" in $$props2) $$invalidate(1, backgroundImage = $$props2.backgroundImage);
    if ("backgroundImageOpacity" in $$props2) $$invalidate(2, backgroundImageOpacity = $$props2.backgroundImageOpacity);
    if ("patternOpacity" in $$props2) $$invalidate(3, patternOpacity = $$props2.patternOpacity);
    if ("patternSize" in $$props2) $$invalidate(4, patternSize = $$props2.patternSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    backgroundColor,
    backgroundImage,
    backgroundImageOpacity,
    patternOpacity,
    patternSize
  ];
}
var StaticBackground = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {
      backgroundColor: 0,
      backgroundImage: 1,
      backgroundImageOpacity: 2,
      patternOpacity: 3,
      patternSize: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StaticBackground",
      options,
      id: create_fragment20.name
    });
  }
  get backgroundColor() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundImage() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundImage(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundImageOpacity() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundImageOpacity(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternOpacity() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternOpacity(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternSize() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternSize(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StaticBackground_default = StaticBackground;

// node_modules/taleem-pivot-player/PivotPlayer.svelte
var file21 = "node_modules/taleem-pivot-player/PivotPlayer.svelte";
function add_css20(target) {
  append_styles(target, "svelte-1fqg8i1", ".stage-wrapper.svelte-1fqg8i1{position:relative;width:100vw;height:100vh;overflow:hidden}.stage.svelte-1fqg8i1{position:absolute;top:0;left:0;width:100%;height:100%;z-index:1}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGl2b3RQbGF5ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvUGl2b3RQbGF5ZXIuc3ZlbHRlIl19 */");
}
function create_else_block2(ctx) {
  let p;
  let t0;
  let t1_value = (
    /*getCurrentSlide*/
    ctx[7]().type + ""
  );
  let t1;
  const block = {
    c: function create() {
      p = element("p");
      t0 = text("Unknown slide type: ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t0 = claim_text(p_nodes, "Unknown slide type: ");
      t1 = claim_text(p_nodes, t1_value);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file21, 86, 6, 1697);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t0);
      append_hydration_dev(p, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(86:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = SlideMap_default[
    /*getCurrentSlide*/
    ctx[7]().type
  ];
  function switch_props(ctx2, dirty) {
    return {
      props: {
        data: (
          /*getCurrentSlide*/
          ctx2[7]().data
        ),
        currentTime: (
          /*currentTime*/
          ctx2[2]
        )
      },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = SlideMap_default[
        /*getCurrentSlide*/
        ctx2[7]().type
      ])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = {};
        if (dirty & /*currentTime*/
        4) switch_instance_changes.currentTime = /*currentTime*/
        ctx2[2];
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(80:4) {#if SlideMap[getCurrentSlide().type]}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let div1;
  let staticbackground;
  let t0;
  let div0;
  let show_if;
  let current_block_type_index;
  let if_block;
  let t1;
  let navbar;
  let current;
  const staticbackground_spread_levels = [
    /*background*/
    ctx[1]
  ];
  let staticbackground_props = {};
  for (let i = 0; i < staticbackground_spread_levels.length; i += 1) {
    staticbackground_props = assign(staticbackground_props, staticbackground_spread_levels[i]);
  }
  staticbackground = new StaticBackground_default({
    props: staticbackground_props,
    $$inline: true
  });
  const if_block_creators = [create_if_block8, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (SlideMap_default[
      /*getCurrentSlide*/
      ctx2[7]().type
    ]) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  navbar = new NavBar_default({
    props: {
      currentTime: (
        /*currentTime*/
        ctx[2]
      ),
      duration: (
        /*deck*/
        ctx[0].at(-1).end
      ),
      onPlay: (
        /*play*/
        ctx[3]
      ),
      onPause: (
        /*pause*/
        ctx[4]
      ),
      onStop: (
        /*stop*/
        ctx[5]
      ),
      onSeek: (
        /*seek*/
        ctx[6]
      ),
      onBack: back
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(staticbackground.$$.fragment);
      t0 = space();
      div0 = element("div");
      if_block.c();
      t1 = space();
      create_component(navbar.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(staticbackground.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if_block.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      claim_component(navbar.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "stage svelte-1fqg8i1");
      add_location(div0, file21, 78, 2, 1475);
      attr_dev(div1, "class", "stage-wrapper svelte-1fqg8i1");
      add_location(div1, file21, 75, 0, 1405);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(staticbackground, div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      append_hydration_dev(div1, t1);
      mount_component(navbar, div1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const staticbackground_changes = dirty & /*background*/
      2 ? get_spread_update(staticbackground_spread_levels, [get_spread_object(
        /*background*/
        ctx2[1]
      )]) : {};
      staticbackground.$set(staticbackground_changes);
      if_block.p(ctx2, dirty);
      const navbar_changes = {};
      if (dirty & /*currentTime*/
      4) navbar_changes.currentTime = /*currentTime*/
      ctx2[2];
      if (dirty & /*deck*/
      1) navbar_changes.duration = /*deck*/
      ctx2[0].at(-1).end;
      navbar.$set(navbar_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(staticbackground.$$.fragment, local);
      transition_in(if_block);
      transition_in(navbar.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(staticbackground.$$.fragment, local);
      transition_out(if_block);
      transition_out(navbar.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(staticbackground);
      if_blocks[current_block_type_index].d();
      destroy_component(navbar);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function back() {
  history.back();
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PivotPlayer", slots, []);
  let { deck = [] } = $$props;
  let { soundUrl = "" } = $$props;
  let { background = {
    backgroundColor: "#ffffff",
    backgroundImage: "",
    backgroundImageOpacity: 1
  } } = $$props;
  let player;
  let currentTime = 0;
  let currentSlideIndex = 0;
  function handleTick(time) {
    var _a;
    const deckEnd = ((_a = deck.at(-1)) == null ? void 0 : _a.end) ?? 10;
    if (time >= deckEnd) {
      player.pause();
      $$invalidate(2, currentTime = deckEnd);
      return;
    }
    $$invalidate(2, currentTime = time);
    for (let i = 0; i < deck.length; i++) {
      const { start, end } = deck[i];
      if (time >= start && time < end) {
        currentSlideIndex = i;
        break;
      }
    }
  }
  onMount(() => {
    player = new Player(soundUrl);
    player.onTick(handleTick);
  });
  onDestroy(() => {
    player.destroy();
  });
  function play() {
    player.play();
  }
  function pause() {
    player.pause();
  }
  function stop() {
    player.pause();
    player.sound.seek(0);
    $$invalidate(2, currentTime = 0);
  }
  function seek(t) {
    player.sound.seek(t);
    handleTick(t);
  }
  const getCurrentSlide = () => deck[currentSlideIndex];
  const writable_props = ["deck", "soundUrl", "background"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PivotPlayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("deck" in $$props2) $$invalidate(0, deck = $$props2.deck);
    if ("soundUrl" in $$props2) $$invalidate(8, soundUrl = $$props2.soundUrl);
    if ("background" in $$props2) $$invalidate(1, background = $$props2.background);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    Player,
    SlideMap: SlideMap_default,
    NavBar: NavBar_default,
    StaticBackground: StaticBackground_default,
    deck,
    soundUrl,
    background,
    player,
    currentTime,
    currentSlideIndex,
    handleTick,
    play,
    pause,
    stop,
    seek,
    back,
    getCurrentSlide
  });
  $$self.$inject_state = ($$props2) => {
    if ("deck" in $$props2) $$invalidate(0, deck = $$props2.deck);
    if ("soundUrl" in $$props2) $$invalidate(8, soundUrl = $$props2.soundUrl);
    if ("background" in $$props2) $$invalidate(1, background = $$props2.background);
    if ("player" in $$props2) player = $$props2.player;
    if ("currentTime" in $$props2) $$invalidate(2, currentTime = $$props2.currentTime);
    if ("currentSlideIndex" in $$props2) currentSlideIndex = $$props2.currentSlideIndex;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    deck,
    background,
    currentTime,
    play,
    pause,
    stop,
    seek,
    getCurrentSlide,
    soundUrl
  ];
}
var PivotPlayer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { deck: 0, soundUrl: 8, background: 1 }, add_css20);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PivotPlayer",
      options,
      id: create_fragment21.name
    });
  }
  get deck() {
    throw new Error("<PivotPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deck(value) {
    throw new Error("<PivotPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get soundUrl() {
    throw new Error("<PivotPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set soundUrl(value) {
    throw new Error("<PivotPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get background() {
    throw new Error("<PivotPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<PivotPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PivotPlayer_default = PivotPlayer;
export {
  PivotPlayer_default as PivotPlayer,
  Player,
  SlideMap_default as SlideMap
};
//# sourceMappingURL=taleem-pivot-player.js.map
