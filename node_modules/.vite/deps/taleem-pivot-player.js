import "./chunk-DYWWDCTU.js";
import {
  HtmlTagHydration,
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  append_styles,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_html_tag,
  claim_space,
  claim_svg_element,
  claim_text,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_svelte_dataset,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  null_to_empty,
  prop_dev,
  run_all,
  safe_not_equal,
  set_data_dev,
  set_style,
  space,
  src_url_equal,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-MT4ZBHI2.js";
import "./chunk-672HPU4M.js";
import "./chunk-V6TY7KAL.js";

// node_modules/taleem-pivot-player/src/slides/BackgroundLayer.svelte
function add_css(target) {
  append_styles(target, "svelte-2ny0az", "\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFja2dyb3VuZExheWVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvQmFja2dyb3VuZExheWVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment(ctx) {
  let html_tag;
  let raw_value = `<div class="background-layer" style="${/*inlineStyle*/
  ctx[0]}"></div>`;
  let html_anchor;
  const block = {
    c: function create() {
      html_tag = new HtmlTagHydration(false);
      html_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      html_tag = claim_html_tag(nodes, false);
      html_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      html_tag.a = html_anchor;
    },
    m: function mount(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert_hydration_dev(target, html_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*inlineStyle*/
      1 && raw_value !== (raw_value = `<div class="background-layer" style="${/*inlineStyle*/
      ctx2[0]}"></div>`)) html_tag.p(raw_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(html_anchor);
        html_tag.d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let inlineStyle;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BackgroundLayer", slots, []);
  let { background = {
    backgroundColor: "#ffffff",
    backgroundImage: "/pivot/defaultBg.png",
    // must be valid
    backgroundImageOpacity: 1
  } } = $$props;
  const writable_props = ["background"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BackgroundLayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("background" in $$props2) $$invalidate(1, background = $$props2.background);
  };
  $$self.$capture_state = () => ({ background, inlineStyle });
  $$self.$inject_state = ($$props2) => {
    if ("background" in $$props2) $$invalidate(1, background = $$props2.background);
    if ("inlineStyle" in $$props2) $$invalidate(0, inlineStyle = $$props2.inlineStyle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*background*/
    2) {
      $: $$invalidate(0, inlineStyle = [
        `background-color: ${background.backgroundColor}`,
        `background-size: cover`,
        `background-position: center`,
        `opacity: ${background.backgroundImageOpacity}`,
        background.backgroundImage ? `background-image: url('${background.backgroundImage}')` : ""
      ].join("; "));
    }
  };
  return [inlineStyle, background];
}
var BackgroundLayer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { background: 1 }, add_css);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BackgroundLayer",
      options,
      id: create_fragment.name
    });
  }
  get background() {
    throw new Error("<BackgroundLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<BackgroundLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BackgroundLayer_default = BackgroundLayer;

// node_modules/taleem-pivot-player/src/slides/SlideWrapper.svelte
var file = "node_modules/taleem-pivot-player/src/slides/SlideWrapper.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1rhxscx", ".slide-wrapper.svelte-1rhxscx{position:absolute;width:100%;height:100%}.slide-content.svelte-1rhxscx{position:relative;z-index:2;width:100%;height:100%}.slide-canvas.svelte-1rhxscx{width:100%;height:100%}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2xpZGVXcmFwcGVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvU2xpZGVXcmFwcGVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment2(ctx) {
  let div2;
  let backgroundlayer;
  let t;
  let div1;
  let div0;
  let current;
  backgroundlayer = new BackgroundLayer_default({
    props: { background: (
      /*background*/
      ctx[0]
    ) },
    $$inline: true
  });
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  const block = {
    c: function create() {
      div2 = element("div");
      create_component(backgroundlayer.$$.fragment);
      t = space();
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      claim_component(backgroundlayer.$$.fragment, div2_nodes);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "slide-canvas svelte-1rhxscx");
      add_location(div0, file, 9, 4, 201);
      attr_dev(div1, "class", "slide-content svelte-1rhxscx");
      add_location(div1, file, 8, 2, 169);
      attr_dev(div2, "class", "slide-wrapper svelte-1rhxscx");
      add_location(div2, file, 6, 0, 104);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      mount_component(backgroundlayer, div2, null);
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const backgroundlayer_changes = {};
      if (dirty & /*background*/
      1) backgroundlayer_changes.background = /*background*/
      ctx2[0];
      backgroundlayer.$set(backgroundlayer_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(backgroundlayer.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(backgroundlayer.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_component(backgroundlayer);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlideWrapper", slots, ["default"]);
  let { background } = $$props;
  $$self.$$.on_mount.push(function() {
    if (background === void 0 && !("background" in $$props || $$self.$$.bound[$$self.$$.props["background"]])) {
      console.warn("<SlideWrapper> was created without expected prop 'background'");
    }
  });
  const writable_props = ["background"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<SlideWrapper> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("background" in $$props2) $$invalidate(0, background = $$props2.background);
    if ("$$scope" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({ BackgroundLayer: BackgroundLayer_default, background });
  $$self.$inject_state = ($$props2) => {
    if ("background" in $$props2) $$invalidate(0, background = $$props2.background);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [background, $$scope, slots];
}
var SlideWrapper = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, { background: 0 }, add_css2);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlideWrapper",
      options,
      id: create_fragment2.name
    });
  }
  get background() {
    throw new Error("<SlideWrapper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set background(value) {
    throw new Error("<SlideWrapper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlideWrapper_default = SlideWrapper;

// node_modules/taleem-pivot-player/src/slides/Quote.svelte
var file2 = "node_modules/taleem-pivot-player/src/slides/Quote.svelte";
function add_css3(target) {
  append_styles(target, "svelte-1096xqm", ".quote-slide.svelte-1096xqm{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;text-align:center;padding:40px}.heading.svelte-1096xqm{font-size:68px;margin-bottom:0.8rem}.author-text.svelte-1096xqm{font-size:28px;opacity:0.85;margin-top:1.6rem}@media(max-width: 480px){.heading.svelte-1096xqm{font-size:32px}.author-text.svelte-1096xqm{font-size:18px}}@media(min-width: 481px) and (max-width: 767px){.heading.svelte-1096xqm{font-size:40px}.author-text.svelte-1096xqm{font-size:20px}}@media(min-width: 768px) and (max-width: 1024px){.heading.svelte-1096xqm{font-size:52px}.author-text.svelte-1096xqm{font-size:24px}}@media(min-width: 1025px) and (max-width: 1440px){.heading.svelte-1096xqm{font-size:60px}.author-text.svelte-1096xqm{font-size:26px}}@media(min-width: 1441px){.heading.svelte-1096xqm{font-size:120px}.author-text.svelte-1096xqm{font-size:35px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVvdGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9RdW90ZS5zdmVsdGUiXX0= */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let h1;
  let t_value = (
    /*line*/
    ctx[3].content + ""
  );
  let t;
  const block = {
    c: function create() {
      h1 = element("h1");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      h1 = claim_element(nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t = claim_text(h1_nodes, t_value);
      h1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "heading svelte-1096xqm");
      add_location(h1, file2, 9, 4, 235);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h1, anchor);
      append_hydration_dev(h1, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(h1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(9:2) {#each quoteLines as line}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div;
  let t0;
  let p;
  let t1;
  let each_value = ensure_array_like_dev(
    /*quoteLines*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      p = element("p");
      t1 = text(
        /*author*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t0 = claim_space(div_nodes);
      p = claim_element(div_nodes, "P", { class: true });
      var p_nodes = children(p);
      t1 = claim_text(
        p_nodes,
        /*author*/
        ctx[1]
      );
      p_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "class", "text-primary author-text svelte-1096xqm");
      add_location(p, file2, 12, 2, 288);
      attr_dev(div, "class", "quote-slide svelte-1096xqm");
      add_location(div, file2, 7, 0, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t0);
      append_hydration_dev(div, p);
      append_hydration_dev(p, t1);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*quoteLines*/
      1) {
        each_value = ensure_array_like_dev(
          /*quoteLines*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Quote", slots, []);
  let { data } = $$props;
  const quoteLines = data.filter((d) => d.name === "quoteLine");
  const author = ((_a = data.find((d) => d.name === "author")) == null ? void 0 : _a.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Quote> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Quote> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, quoteLines, author });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [quoteLines, author, data];
}
var Quote = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { data: 2 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Quote",
      options,
      id: create_fragment3.name
    });
  }
  get data() {
    throw new Error("<Quote>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Quote>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Quote_default = Quote;

// node_modules/taleem-pivot-player/src/slides/CornerWords.svelte
var file3 = "node_modules/taleem-pivot-player/src/slides/CornerWords.svelte";
function add_css4(target) {
  append_styles(target, "svelte-2ovd7j", ".card-grid.svelte-2ovd7j{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;width:100%;height:100%;box-sizing:border-box}.card.svelte-2ovd7j{display:flex;flex-direction:column;justify-content:center;align-items:center;border:3px solid currentColor;border-radius:16px;box-sizing:border-box;width:100%;height:100%;padding:20px;text-align:center}.icon.svelte-2ovd7j{font-size:clamp(40px, 10vw, 80px);margin-bottom:12px}.label.svelte-2ovd7j{font-size:clamp(18px, 3vw, 28px);font-weight:bold;line-height:1.2}@media(max-width: 600px){.card.svelte-2ovd7j{padding:2px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29ybmVyV29yZHMuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9Db3JuZXJXb3Jkcy5zdmVsdGUiXX0= */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let div2;
  let div0;
  let t0_value = (
    /*card*/
    ctx[2].icon + ""
  );
  let t0;
  let t1;
  let div1;
  let t2_value = (
    /*card*/
    ctx[2].label + ""
  );
  let t2;
  let t3;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = text(t2_value);
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, t0_value);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(div1_nodes, t2_value);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "icon svelte-2ovd7j");
      add_location(div0, file3, 8, 6, 182);
      attr_dev(div1, "class", "label svelte-2ovd7j");
      add_location(div1, file3, 9, 6, 224);
      attr_dev(div2, "class", "card svelte-2ovd7j");
      add_location(div2, file3, 7, 4, 157);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div2, t3);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(7:2) {#each cards as card}",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*cards*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "card-grid text-primary svelte-2ovd7j");
      add_location(div, file3, 5, 0, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*cards*/
      1) {
        each_value = ensure_array_like_dev(
          /*cards*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CornerWords", slots, []);
  let { data } = $$props;
  const cards = data.filter((d) => d.name === "card");
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<CornerWords> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<CornerWords> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, cards });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [cards, data];
}
var CornerWords = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { data: 1 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerWords",
      options,
      id: create_fragment4.name
    });
  }
  get data() {
    throw new Error("<CornerWords>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<CornerWords>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CornerWords_default = CornerWords;

// node_modules/taleem-pivot-player/src/slides/Title.svelte
var file4 = "node_modules/taleem-pivot-player/src/slides/Title.svelte";
function add_css5(target) {
  append_styles(target, "svelte-1rlf2bs", ".title-slide.svelte-1rlf2bs{display:flex;justify-content:center;align-items:center;height:100%;text-align:center;padding:40px;box-sizing:border-box}.main-title.svelte-1rlf2bs{font-weight:bold;line-height:1.2;text-wrap:balance;font-size:72px;text-shadow:8px 8px 22px var(--shadowColor)}@media(max-width: 480px){.main-title.svelte-1rlf2bs{font-size:36px}}@media(min-width: 481px) and (max-width: 767px){.main-title.svelte-1rlf2bs{font-size:48px}}@media(min-width: 768px) and (max-width: 1024px){.main-title.svelte-1rlf2bs{font-size:60px}}@media(min-width: 1025px) and (max-width: 1440px){.main-title.svelte-1rlf2bs{font-size:72px}}@media(min-width: 1441px){.main-title.svelte-1rlf2bs{font-size:100px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGl0bGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9UaXRsZS5zdmVsdGUiXX0= */");
}
function create_fragment5(ctx) {
  let div;
  let h1;
  let t;
  const block = {
    c: function create() {
      div = element("div");
      h1 = element("h1");
      t = text(
        /*title*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h1 = claim_element(div_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t = claim_text(
        h1_nodes,
        /*title*/
        ctx[0]
      );
      h1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "main-title svelte-1rlf2bs");
      add_location(h1, file4, 6, 4, 146);
      attr_dev(div, "class", "title-slide svelte-1rlf2bs");
      add_location(div, file4, 5, 2, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h1);
      append_hydration_dev(h1, t);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Title", slots, []);
  let { data } = $$props;
  const title = ((_a = data.find((d) => d.name === "title")) == null ? void 0 : _a.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Title> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Title> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, title });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, data];
}
var Title = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { data: 1 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Title",
      options,
      id: create_fragment5.name
    });
  }
  get data() {
    throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Title_default = Title;

// node_modules/taleem-pivot-player/src/slides/ImageLeftBulletsRight.svelte
var file5 = "node_modules/taleem-pivot-player/src/slides/ImageLeftBulletsRight.svelte";
function add_css6(target) {
  append_styles(target, "svelte-19neic9", ".slide-grid.svelte-19neic9.svelte-19neic9{display:grid;grid-template-columns:30% 70%;height:100vh;width:100vw;padding:2rem;padding-left:12rem;box-sizing:border-box;gap:2rem}.image-zone.svelte-19neic9.svelte-19neic9{display:flex;justify-content:flex-start;align-items:center;overflow:hidden}.image-zone.svelte-19neic9 img.svelte-19neic9{display:block;max-width:100%;height:auto;-o-object-fit:contain;object-fit:contain}.bullets-zone.svelte-19neic9.svelte-19neic9{display:flex;flex-direction:column;justify-content:center;gap:2rem;padding-right:1rem}.bullet-item.svelte-19neic9.svelte-19neic9{font-size:4rem;line-height:2.5;font-weight:500}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VMZWZ0QnVsbGV0c1JpZ2h0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvSW1hZ2VMZWZ0QnVsbGV0c1JpZ2h0LnN2ZWx0ZSJdfQ== */");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block3(ctx) {
  let div;
  let t_value = (
    /*bullet*/
    ctx[3] + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "bullet-item svelte-19neic9");
      add_location(div, file5, 13, 6, 358);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(13:4) {#each bullets as bullet}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div2;
  let div0;
  let img;
  let img_src_value;
  let t;
  let div1;
  let each_value = ensure_array_like_dev(
    /*bullets*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      img = element("img");
      t = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      img = claim_element(div0_nodes, "IMG", { src: true, alt: true, class: true });
      div0_nodes.forEach(detach_dev);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      attr_dev(img, "class", "svelte-19neic9");
      add_location(img, file5, 9, 4, 243);
      attr_dev(div0, "class", "image-zone svelte-19neic9");
      add_location(div0, file5, 8, 2, 214);
      attr_dev(div1, "class", "bullets-zone svelte-19neic9");
      add_location(div1, file5, 11, 2, 295);
      attr_dev(div2, "class", "slide-grid svelte-19neic9");
      add_location(div2, file5, 7, 0, 187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, img);
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*bullets*/
      2) {
        each_value = ensure_array_like_dev(
          /*bullets*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageLeftBulletsRight", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  const bullets = data.filter((d) => d.name === "bullet").map((b) => b.content);
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageLeftBulletsRight> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageLeftBulletsRight> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc, bullets });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, bullets, data];
}
var ImageLeftBulletsRight = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { data: 2 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageLeftBulletsRight",
      options,
      id: create_fragment6.name
    });
  }
  get data() {
    throw new Error("<ImageLeftBulletsRight>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageLeftBulletsRight>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageLeftBulletsRight_default = ImageLeftBulletsRight;

// node_modules/taleem-pivot-player/src/slides/Image.svelte
var file6 = "node_modules/taleem-pivot-player/src/slides/Image.svelte";
function add_css7(target) {
  append_styles(target, "svelte-ucn0n7", ".image-slide.svelte-ucn0n7.svelte-ucn0n7{position:relative;width:100%;height:100%;padding:0;display:flex;justify-content:center;align-items:center;box-sizing:border-box}.full-image.svelte-ucn0n7.svelte-ucn0n7{width:auto;height:auto;max-width:90vw;max-height:90vh;aspect-ratio:16 / 9;-o-object-fit:contain;object-fit:contain;border-radius:12px;box-shadow:0 0 30px rgba(0, 0, 0, 0.2)}@media(max-width: 480px){.image-slide.svelte-ucn0n7.svelte-ucn0n7{padding:20px}.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:300px}}@media(min-width: 481px) and (max-width: 767px){.image-slide.svelte-ucn0n7.svelte-ucn0n7{padding:30px}.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:400px}}@media(min-width: 768px) and (max-width: 1024px){.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:500px}}@media(min-width: 1025px) and (max-width: 1440px){.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:600px}}@media(min-width: 1441px){.image-slide.svelte-ucn0n7 img.svelte-ucn0n7{max-height:900px}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9JbWFnZS5zdmVsdGUiXX0= */");
}
function create_fragment7(ctx) {
  let div;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      img = claim_element(div_nodes, "IMG", { class: true, src: true, alt: true });
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "class", "full-image svelte-ucn0n7");
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      add_location(img, file6, 8, 4, 200);
      attr_dev(div, "class", "image-slide svelte-ucn0n7");
      add_location(div, file6, 6, 2, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Image", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Image> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Image> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, data];
}
var Image = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { data: 1 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment7.name
    });
  }
  get data() {
    throw new Error("<Image>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Image>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Image_default = Image;

// node_modules/taleem-pivot-player/src/background/StaticBackground.svelte
var file7 = "node_modules/taleem-pivot-player/src/background/StaticBackground.svelte";
function create_if_block(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(div, "background-image", "url(" + /*backgroundImage*/
      ctx[1] + ")");
      set_style(div, "background-size", "cover");
      set_style(div, "background-position", "center");
      set_style(
        div,
        "opacity",
        /*backgroundImageOpacity*/
        ctx[2]
      );
      set_style(div, "position", "absolute");
      set_style(div, "top", "0");
      set_style(div, "left", "0");
      set_style(div, "width", "100%");
      set_style(div, "height", "100%");
      set_style(div, "z-index", "1");
      add_location(div, file7, 23, 4, 497);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*backgroundImage*/
      2) {
        set_style(div, "background-image", "url(" + /*backgroundImage*/
        ctx2[1] + ")");
      }
      if (dirty & /*backgroundImageOpacity*/
      4) {
        set_style(
          div,
          "opacity",
          /*backgroundImageOpacity*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(23:2) {#if backgroundImage}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let div0;
  let t0;
  let t1;
  let div1;
  let if_block = (
    /*backgroundImage*/
    ctx[1] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div0 = element("div");
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div0 = claim_element(nodes, "DIV", { style: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      t1 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", { style: true });
      children(div1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_style(
        div0,
        "background-color",
        /*backgroundColor*/
        ctx[0]
      );
      set_style(div0, "position", "absolute");
      set_style(div0, "top", "0");
      set_style(div0, "left", "0");
      set_style(div0, "width", "100%");
      set_style(div0, "height", "100%");
      set_style(div0, "z-index", "0");
      add_location(div0, file7, 9, 2, 252);
      set_style(div1, "background-image", "radial-gradient(rgba(255,255,255," + /*patternOpacity*/
      ctx[3] + ") 1px, transparent 1px)");
      set_style(
        div1,
        "background-size",
        /*patternSize*/
        ctx[4] + "px " + /*patternSize*/
        ctx[4] + "px"
      );
      set_style(div1, "position", "absolute");
      set_style(div1, "top", "0");
      set_style(div1, "left", "0");
      set_style(div1, "width", "100%");
      set_style(div1, "height", "100%");
      set_style(div1, "z-index", "2");
      set_style(div1, "pointer-events", "none");
      add_location(div1, file7, 40, 2, 863);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div0, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div1, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*backgroundColor*/
      1) {
        set_style(
          div0,
          "background-color",
          /*backgroundColor*/
          ctx2[0]
        );
      }
      if (
        /*backgroundImage*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*patternOpacity*/
      8) {
        set_style(div1, "background-image", "radial-gradient(rgba(255,255,255," + /*patternOpacity*/
        ctx2[3] + ") 1px, transparent 1px)");
      }
      if (dirty & /*patternSize*/
      16) {
        set_style(
          div1,
          "background-size",
          /*patternSize*/
          ctx2[4] + "px " + /*patternSize*/
          ctx2[4] + "px"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div0);
        detach_dev(t0);
        detach_dev(t1);
        detach_dev(div1);
      }
      if (if_block) if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StaticBackground", slots, []);
  let { backgroundColor = "#0e490f" } = $$props;
  let { backgroundImage = null } = $$props;
  let { backgroundImageOpacity = 0.07 } = $$props;
  let { patternOpacity = 0.25 } = $$props;
  let { patternSize = 28 } = $$props;
  const writable_props = [
    "backgroundColor",
    "backgroundImage",
    "backgroundImageOpacity",
    "patternOpacity",
    "patternSize"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<StaticBackground> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("backgroundColor" in $$props2) $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("backgroundImage" in $$props2) $$invalidate(1, backgroundImage = $$props2.backgroundImage);
    if ("backgroundImageOpacity" in $$props2) $$invalidate(2, backgroundImageOpacity = $$props2.backgroundImageOpacity);
    if ("patternOpacity" in $$props2) $$invalidate(3, patternOpacity = $$props2.patternOpacity);
    if ("patternSize" in $$props2) $$invalidate(4, patternSize = $$props2.patternSize);
  };
  $$self.$capture_state = () => ({
    backgroundColor,
    backgroundImage,
    backgroundImageOpacity,
    patternOpacity,
    patternSize
  });
  $$self.$inject_state = ($$props2) => {
    if ("backgroundColor" in $$props2) $$invalidate(0, backgroundColor = $$props2.backgroundColor);
    if ("backgroundImage" in $$props2) $$invalidate(1, backgroundImage = $$props2.backgroundImage);
    if ("backgroundImageOpacity" in $$props2) $$invalidate(2, backgroundImageOpacity = $$props2.backgroundImageOpacity);
    if ("patternOpacity" in $$props2) $$invalidate(3, patternOpacity = $$props2.patternOpacity);
    if ("patternSize" in $$props2) $$invalidate(4, patternSize = $$props2.patternSize);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    backgroundColor,
    backgroundImage,
    backgroundImageOpacity,
    patternOpacity,
    patternSize
  ];
}
var StaticBackground = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, {
      backgroundColor: 0,
      backgroundImage: 1,
      backgroundImageOpacity: 2,
      patternOpacity: 3,
      patternSize: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StaticBackground",
      options,
      id: create_fragment8.name
    });
  }
  get backgroundColor() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundColor(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundImage() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundImage(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get backgroundImageOpacity() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set backgroundImageOpacity(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternOpacity() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternOpacity(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get patternSize() {
    throw new Error("<StaticBackground>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set patternSize(value) {
    throw new Error("<StaticBackground>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StaticBackground_default = StaticBackground;

// node_modules/taleem-pivot-player/src/slides/ImageRightBulletsLeft.svelte
var file8 = "node_modules/taleem-pivot-player/src/slides/ImageRightBulletsLeft.svelte";
function add_css8(target) {
  append_styles(target, "svelte-10uh9r1", ".slide-flex.svelte-10uh9r1.svelte-10uh9r1{display:flex;width:100vw;height:100vh;box-sizing:border-box;padding:8rem 10rem;gap:2rem}.bullets-zone.svelte-10uh9r1.svelte-10uh9r1{flex:6;display:flex;flex-direction:column;justify-content:center;gap:2rem}.bullet-item.svelte-10uh9r1.svelte-10uh9r1{font-size:4rem;font-weight:500;line-height:2.5}.image-zone.svelte-10uh9r1.svelte-10uh9r1{flex:4;display:flex;align-items:center;justify-content:center;overflow:hidden}.image-zone.svelte-10uh9r1 img.svelte-10uh9r1{max-width:100%;max-height:100%;-o-object-fit:contain;object-fit:contain;display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VSaWdodEJ1bGxldHNMZWZ0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvSW1hZ2VSaWdodEJ1bGxldHNMZWZ0LnN2ZWx0ZSJdfQ== */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let div;
  let t_value = (
    /*bullet*/
    ctx[3] + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "bullet-item svelte-10uh9r1");
      add_location(div, file8, 10, 8, 297);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(10:6) {#each bullets as bullet}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let img;
  let img_src_value;
  let each_value = ensure_array_like_dev(
    /*bullets*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div1 = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      img = claim_element(div1_nodes, "IMG", { src: true, alt: true, class: true });
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "bullets-zone svelte-10uh9r1");
      add_location(div0, file8, 8, 4, 230);
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      attr_dev(img, "class", "svelte-10uh9r1");
      add_location(img, file8, 15, 6, 400);
      attr_dev(div1, "class", "image-zone svelte-10uh9r1");
      add_location(div1, file8, 14, 4, 369);
      attr_dev(div2, "class", "slide-flex svelte-10uh9r1");
      add_location(div2, file8, 7, 2, 201);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, img);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*bullets*/
      2) {
        each_value = ensure_array_like_dev(
          /*bullets*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageRightBulletsLeft", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  const bullets = data.filter((d) => d.name === "bullet").map((b) => b.content);
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageRightBulletsLeft> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageRightBulletsLeft> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc, bullets });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, bullets, data];
}
var ImageRightBulletsLeft = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, { data: 2 }, add_css8);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageRightBulletsLeft",
      options,
      id: create_fragment9.name
    });
  }
  get data() {
    throw new Error("<ImageRightBulletsLeft>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageRightBulletsLeft>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageRightBulletsLeft_default = ImageRightBulletsLeft;

// node_modules/taleem-pivot-player/src/slides/ImageWithCaption.svelte
var file9 = "node_modules/taleem-pivot-player/src/slides/ImageWithCaption.svelte";
function add_css9(target) {
  append_styles(target, "svelte-17cvzhn", ".image-slide.svelte-17cvzhn{position:relative;width:100%;height:100%;display:flex;justify-content:center;align-items:center}.full-image.svelte-17cvzhn{max-width:90vw;max-height:90vh;-o-object-fit:contain;object-fit:contain;border-radius:12px;box-shadow:0 0 30px rgba(0, 0, 0, 0.2)}.text-overlay.caption.svelte-17cvzhn{position:absolute;bottom:5%;left:50%;transform:translateX(-50%);font-size:2.5rem;color:white;text-shadow:1px 1px 4px black}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VXaXRoQ2FwdGlvbi5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zcmMvc2xpZGVzL0ltYWdlV2l0aENhcHRpb24uc3ZlbHRlIl19 */");
}
function create_fragment10(ctx) {
  let div1;
  let img;
  let img_src_value;
  let t0;
  let div0;
  let t1;
  const block = {
    c: function create() {
      div1 = element("div");
      img = element("img");
      t0 = space();
      div0 = element("div");
      t1 = text(
        /*caption*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      img = claim_element(div1_nodes, "IMG", { class: true, src: true, alt: true });
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t1 = claim_text(
        div0_nodes,
        /*caption*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(img, "class", "full-image svelte-17cvzhn");
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      add_location(img, file9, 7, 4, 222);
      attr_dev(div0, "class", "text-overlay caption svelte-17cvzhn");
      add_location(div0, file9, 8, 4, 286);
      attr_dev(div1, "class", "image-slide svelte-17cvzhn");
      add_location(div1, file9, 6, 2, 192);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, img);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageWithCaption", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  const caption = ((_b = data.find((d) => d.name === "caption")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageWithCaption> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageWithCaption> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc, caption });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, caption, data];
}
var ImageWithCaption = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, { data: 2 }, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageWithCaption",
      options,
      id: create_fragment10.name
    });
  }
  get data() {
    throw new Error("<ImageWithCaption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageWithCaption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageWithCaption_default = ImageWithCaption;

// node_modules/taleem-pivot-player/src/slides/ImageWithTitle.svelte
var file10 = "node_modules/taleem-pivot-player/src/slides/ImageWithTitle.svelte";
function add_css10(target) {
  append_styles(target, "svelte-1llvupf", ".slide-container.svelte-1llvupf.svelte-1llvupf{display:flex;flex-direction:column;align-items:center;padding:20px;box-sizing:border-box;height:100%;width:100%;gap:20px}.title-zone.svelte-1llvupf.svelte-1llvupf{text-align:center}.slide-title.svelte-1llvupf.svelte-1llvupf{padding-top:4rem;font-size:4rem;margin:0}.image-zone.svelte-1llvupf.svelte-1llvupf{max-width:70%;max-height:70%;display:flex;justify-content:center}.image-zone.svelte-1llvupf img.svelte-1llvupf{max-width:100%;height:auto;-o-object-fit:contain;object-fit:contain}@media(max-width: 768px){.slide-title.svelte-1llvupf.svelte-1llvupf{font-size:1.5rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW1hZ2VXaXRoVGl0bGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9JbWFnZVdpdGhUaXRsZS5zdmVsdGUiXX0= */");
}
function create_fragment11(ctx) {
  let div2;
  let div0;
  let h1;
  let t0;
  let t1;
  let div1;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      h1 = element("h1");
      t0 = text(
        /*title*/
        ctx[1]
      );
      t1 = space();
      div1 = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      h1 = claim_element(div0_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*title*/
        ctx[1]
      );
      h1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      img = claim_element(div1_nodes, "IMG", { src: true, alt: true, class: true });
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "slide-title svelte-1llvupf");
      add_location(h1, file10, 9, 4, 238);
      attr_dev(div0, "class", "title-zone svelte-1llvupf");
      add_location(div0, file10, 8, 2, 209);
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[0])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Slide Image");
      attr_dev(img, "class", "svelte-1llvupf");
      add_location(img, file10, 12, 4, 315);
      attr_dev(div1, "class", "image-zone svelte-1llvupf");
      add_location(div1, file10, 11, 2, 286);
      attr_dev(div2, "class", "slide-container svelte-1llvupf");
      add_location(div2, file10, 7, 0, 177);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ImageWithTitle", slots, []);
  let { data } = $$props;
  const imageSrc = ((_a = data.find((d) => d.name === "image")) == null ? void 0 : _a.content) ?? "";
  const title = ((_b = data.find((d) => d.name === "title")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ImageWithTitle> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ImageWithTitle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, imageSrc, title });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [imageSrc, title, data];
}
var ImageWithTitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { data: 2 }, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ImageWithTitle",
      options,
      id: create_fragment11.name
    });
  }
  get data() {
    throw new Error("<ImageWithTitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ImageWithTitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ImageWithTitle_default = ImageWithTitle;

// node_modules/taleem-pivot-player/src/slides/Table.svelte
var file11 = "node_modules/taleem-pivot-player/src/slides/Table.svelte";
function add_css11(target) {
  append_styles(target, "svelte-ovl28n", ".table-slide.svelte-ovl28n{display:flex;justify-content:center;align-items:center;height:100vh;padding:2rem;box-sizing:border-box}table.svelte-ovl28n{width:90%;border-collapse:collapse;font-size:2rem;box-shadow:0 0 10px rgba(0, 0, 0, 0.15)}th.svelte-ovl28n,td.svelte-ovl28n{padding:1rem 1.5rem;text-align:left;border:1px solid #ccc}th.svelte-ovl28n{background-color:#f0f0f0;font-weight:600}@media(max-width: 768px){table.svelte-ovl28n{font-size:1.4rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9UYWJsZS5zdmVsdGUiXX0= */");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  child_ctx[4] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let td;
  let t_value = (
    /*cell*/
    ctx[5] + ""
  );
  let t;
  const block = {
    c: function create() {
      td = element("td");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      t = claim_text(td_nodes, t_value);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(td, "class", "svelte-ovl28n");
      add_location(td, file11, 16, 14, 392);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      append_hydration_dev(td, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(16:12) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let th;
  let t_value = (
    /*cell*/
    ctx[5] + ""
  );
  let t;
  const block = {
    c: function create() {
      th = element("th");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", { class: true });
      var th_nodes = children(th);
      t = claim_text(th_nodes, t_value);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(th, "class", "svelte-ovl28n");
      add_location(th, file11, 14, 14, 342);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      append_hydration_dev(th, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(14:12) {#if i === 0}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*i*/
      ctx2[4] === 0
    ) return create_if_block2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if_block.p(ctx2, dirty);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(13:10) {#each row as cell}",
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let tr;
  let t;
  let each_value_1 = ensure_array_like_dev(
    /*row*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      tr = element("tr");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", {});
      var tr_nodes = children(tr);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(tr_nodes);
      }
      t = claim_space(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(tr, file11, 11, 8, 267);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(tr, null);
        }
      }
      append_hydration_dev(tr, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*tableData*/
      1) {
        each_value_1 = ensure_array_like_dev(
          /*row*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(tr, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(11:6) {#each tableData as row, i}",
    ctx
  });
  return block;
}
function create_fragment12(ctx) {
  let div;
  let table;
  let each_value = ensure_array_like_dev(
    /*tableData*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      table = element("table");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      table = claim_element(div_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(table_nodes);
      }
      table_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(table, "class", "svelte-ovl28n");
      add_location(table, file11, 9, 4, 217);
      attr_dev(div, "class", "table-slide svelte-ovl28n");
      add_location(div, file11, 8, 2, 187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, table);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(table, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*tableData*/
      1) {
        each_value = ensure_array_like_dev(
          /*tableData*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(table, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance12($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  let { data } = $$props;
  const tableData = ((_a = data.find((d) => d.name === "table")) == null ? void 0 : _a.content) ?? [];
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<Table> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<Table> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, tableData });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [tableData, data];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, { data: 1 }, add_css11);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment12.name
    });
  }
  get data() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/taleem-pivot-player/src/slides/StatisticSlide.svelte
var file12 = "node_modules/taleem-pivot-player/src/slides/StatisticSlide.svelte";
function add_css12(target) {
  append_styles(target, "svelte-x6jlyi", ".stat-slide.svelte-x6jlyi{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;width:100vw;text-align:center;gap:1rem}.stat-number.svelte-x6jlyi{font-size:10rem;font-weight:800;color:#333}.stat-label.svelte-x6jlyi{font-size:3rem;font-weight:500;color:#555}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhdGlzdGljU2xpZGUuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9TdGF0aXN0aWNTbGlkZS5zdmVsdGUiXX0= */");
}
function create_fragment13(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*number*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*number*/
        ctx[0]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*label*/
        ctx[1]
      );
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "stat-number svelte-x6jlyi");
      add_location(div0, file12, 8, 4, 219);
      attr_dev(div1, "class", "stat-label svelte-x6jlyi");
      add_location(div1, file12, 9, 4, 263);
      attr_dev(div2, "class", "stat-slide svelte-x6jlyi");
      add_location(div2, file12, 7, 2, 190);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("StatisticSlide", slots, []);
  let { data } = $$props;
  const number = ((_a = data.find((d) => d.name === "number")) == null ? void 0 : _a.content) ?? "";
  const label = ((_b = data.find((d) => d.name === "label")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<StatisticSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<StatisticSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, number, label });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [number, label, data];
}
var StatisticSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, { data: 2 }, add_css12);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StatisticSlide",
      options,
      id: create_fragment13.name
    });
  }
  get data() {
    throw new Error("<StatisticSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<StatisticSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var StatisticSlide_default = StatisticSlide;

// node_modules/taleem-pivot-player/src/slides/BarChartSlide.svelte
var file13 = "node_modules/taleem-pivot-player/src/slides/BarChartSlide.svelte";
function add_css13(target) {
  append_styles(target, "svelte-nh8gru", ".bar-chart-slide.svelte-nh8gru{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100vh;width:100vw;padding:4rem;box-sizing:border-box}.chart-title.svelte-nh8gru{font-size:4rem;font-weight:700;margin-bottom:3rem;text-align:center}.bar-list.svelte-nh8gru{width:100%;display:flex;padding-left:3rem;flex-direction:column;gap:2rem}.bar-row.svelte-nh8gru{display:flex;align-items:center;gap:1rem}.bar-label.svelte-nh8gru{width:20%;font-size:2rem;font-weight:600}.bar-track.svelte-nh8gru{flex:1;height:2.5rem;background-color:#eee;border-radius:1.25rem;overflow:hidden}.bar-fill.svelte-nh8gru{height:100%;border-radius:1.25rem 0 0 1.25rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmFyQ2hhcnRTbGlkZS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zcmMvc2xpZGVzL0JhckNoYXJ0U2xpZGUuc3ZlbHRlIl19 */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i].label;
  child_ctx[4] = list[i].value;
  child_ctx[5] = list[i].color;
  return child_ctx;
}
function create_each_block6(ctx) {
  let div3;
  let div0;
  let t0_value = (
    /*label*/
    ctx[3] + ""
  );
  let t0;
  let t1;
  let div2;
  let div1;
  let t2;
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(div0_nodes, t0_value);
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "bar-label svelte-nh8gru");
      add_location(div0, file13, 13, 10, 359);
      attr_dev(div1, "class", "bar-fill svelte-nh8gru");
      set_style(
        div1,
        "width",
        /*value*/
        ctx[4] + "%"
      );
      set_style(
        div1,
        "background-color",
        /*color*/
        ctx[5]
      );
      add_location(div1, file13, 15, 12, 442);
      attr_dev(div2, "class", "bar-track svelte-nh8gru");
      add_location(div2, file13, 14, 10, 406);
      attr_dev(div3, "class", "bar-row svelte-nh8gru");
      add_location(div3, file13, 12, 8, 327);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div3, t2);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(12:6) {#each bars as { label, value, color }}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let div1;
  let h1;
  let t0;
  let t1;
  let div0;
  let each_value = ensure_array_like_dev(
    /*bars*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      h1 = element("h1");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      h1 = claim_element(div1_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*title*/
        ctx[0]
      );
      h1_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "chart-title svelte-nh8gru");
      add_location(h1, file13, 8, 4, 206);
      attr_dev(div0, "class", "bar-list svelte-nh8gru");
      add_location(div0, file13, 10, 4, 250);
      attr_dev(div1, "class", "bar-chart-slide svelte-nh8gru");
      add_location(div1, file13, 7, 2, 172);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*bars*/
      2) {
        each_value = ensure_array_like_dev(
          /*bars*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  var _a;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BarChartSlide", slots, []);
  let { data } = $$props;
  const title = ((_a = data.find((d) => d.name === "title")) == null ? void 0 : _a.content) ?? "";
  const bars = data.filter((d) => d.name === "bar");
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BarChartSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BarChartSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, title, bars });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, bars, data];
}
var BarChartSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, { data: 2 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChartSlide",
      options,
      id: create_fragment14.name
    });
  }
  get data() {
    throw new Error("<BarChartSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BarChartSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BarChartSlide_default = BarChartSlide;

// node_modules/taleem-pivot-player/src/slides/TwoColumnTextSlide.svelte
var file14 = "node_modules/taleem-pivot-player/src/slides/TwoColumnTextSlide.svelte";
function add_css14(target) {
  append_styles(target, "svelte-1ox8dd3", ".two-col-slide.svelte-1ox8dd3{height:100vh;width:100vw;padding:4rem;box-sizing:border-box;display:flex;flex-direction:column;gap:3rem}.slide-title.svelte-1ox8dd3{font-size:4rem;padding-top:4rem;text-align:center;font-weight:bold}.columns.svelte-1ox8dd3{display:flex;padding-left:20rem;gap:4rem;flex:1}.column.svelte-1ox8dd3{flex:1;font-size:2.5rem;white-space:pre-line;line-height:1.7}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHdvQ29sdW1uVGV4dFNsaWRlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvVHdvQ29sdW1uVGV4dFNsaWRlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment15(ctx) {
  let div3;
  let h1;
  let t0;
  let t1;
  let div2;
  let div0;
  let t2;
  let t3;
  let div1;
  let t4;
  const block = {
    c: function create() {
      div3 = element("div");
      h1 = element("h1");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      div2 = element("div");
      div0 = element("div");
      t2 = text(
        /*left*/
        ctx[1]
      );
      t3 = space();
      div1 = element("div");
      t4 = text(
        /*right*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      h1 = claim_element(div3_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*title*/
        ctx[0]
      );
      h1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t2 = claim_text(
        div0_nodes,
        /*left*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t4 = claim_text(
        div1_nodes,
        /*right*/
        ctx[2]
      );
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "slide-title svelte-1ox8dd3");
      add_location(h1, file14, 9, 4, 287);
      attr_dev(div0, "class", "column svelte-1ox8dd3");
      add_location(div0, file14, 11, 6, 356);
      attr_dev(div1, "class", "column svelte-1ox8dd3");
      add_location(div1, file14, 12, 6, 395);
      attr_dev(div2, "class", "columns svelte-1ox8dd3");
      add_location(div2, file14, 10, 4, 328);
      attr_dev(div3, "class", "two-col-slide svelte-1ox8dd3");
      add_location(div3, file14, 8, 2, 255);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t2);
      append_hydration_dev(div2, t3);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t4);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance15($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TwoColumnTextSlide", slots, []);
  let { data } = $$props;
  const title = ((_a = data.find((d) => d.name === "title")) == null ? void 0 : _a.content) ?? "";
  const left = ((_b = data.find((d) => d.name === "left")) == null ? void 0 : _b.content) ?? "";
  const right = ((_c = data.find((d) => d.name === "right")) == null ? void 0 : _c.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<TwoColumnTextSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TwoColumnTextSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, title, left, right });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, left, right, data];
}
var TwoColumnTextSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { data: 3 }, add_css14);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TwoColumnTextSlide",
      options,
      id: create_fragment15.name
    });
  }
  get data() {
    throw new Error("<TwoColumnTextSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<TwoColumnTextSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TwoColumnTextSlide_default = TwoColumnTextSlide;

// node_modules/taleem-pivot-player/src/slides/DonutChartSlide.svelte
var file15 = "node_modules/taleem-pivot-player/src/slides/DonutChartSlide.svelte";
function add_css15(target) {
  append_styles(target, "svelte-180u8c1", ".donut-slide.svelte-180u8c1{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;gap:2rem}svg.svelte-180u8c1{transform:rotate(-90deg)}.track.svelte-180u8c1{fill:none;stroke:#eee;stroke-width:20}.fill.svelte-180u8c1{fill:none;stroke-width:20;stroke-linecap:round;transition:stroke-dashoffset 1s ease}.center-text.svelte-180u8c1{fill:#333;font-size:2.5rem;font-weight:bold;transform:rotate(90deg)}.donut-label.svelte-180u8c1{font-size:2.5rem;font-weight:500}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRG9udXRDaGFydFNsaWRlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvRG9udXRDaGFydFNsaWRlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment16(ctx) {
  let div1;
  let svg;
  let circle0;
  let circle1;
  let text_1;
  let t0;
  let t1;
  let t2;
  let div0;
  let t3;
  const block = {
    c: function create() {
      div1 = element("div");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      text_1 = svg_element("text");
      t0 = text(
        /*percent*/
        ctx[0]
      );
      t1 = text("%");
      t2 = space();
      div0 = element("div");
      t3 = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      svg = claim_svg_element(div1_nodes, "svg", {
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", { class: true, cx: true, cy: true, r: true });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        cx: true,
        cy: true,
        r: true,
        stroke: true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true
      });
      children(circle1).forEach(detach_dev);
      text_1 = claim_svg_element(svg_nodes, "text", {
        x: true,
        y: true,
        "text-anchor": true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t0 = claim_text(
        text_1_nodes,
        /*percent*/
        ctx[0]
      );
      t1 = claim_text(text_1_nodes, "%");
      text_1_nodes.forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      t2 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t3 = claim_text(
        div0_nodes,
        /*label*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "class", "track svelte-180u8c1");
      attr_dev(circle0, "cx", "100");
      attr_dev(circle0, "cy", "100");
      attr_dev(circle0, "r", "80");
      add_location(circle0, file15, 13, 6, 469);
      attr_dev(circle1, "class", "fill svelte-180u8c1");
      attr_dev(circle1, "cx", "100");
      attr_dev(circle1, "cy", "100");
      attr_dev(circle1, "r", "80");
      attr_dev(
        circle1,
        "stroke",
        /*color*/
        ctx[2]
      );
      attr_dev(
        circle1,
        "stroke-dasharray",
        /*circumference*/
        ctx[3]
      );
      attr_dev(
        circle1,
        "stroke-dashoffset",
        /*offset*/
        ctx[4]
      );
      add_location(circle1, file15, 14, 6, 525);
      attr_dev(text_1, "x", "100");
      attr_dev(text_1, "y", "110");
      attr_dev(text_1, "text-anchor", "middle");
      attr_dev(text_1, "class", "center-text svelte-180u8c1");
      add_location(text_1, file15, 23, 6, 717);
      attr_dev(svg, "width", "200");
      attr_dev(svg, "height", "200");
      attr_dev(svg, "viewBox", "0 0 200 200");
      attr_dev(svg, "class", "svelte-180u8c1");
      add_location(svg, file15, 12, 4, 410);
      attr_dev(div0, "class", "donut-label svelte-180u8c1");
      add_location(div0, file15, 25, 4, 813);
      attr_dev(div1, "class", "donut-slide svelte-180u8c1");
      add_location(div1, file15, 11, 2, 380);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, svg);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      append_hydration_dev(svg, text_1);
      append_hydration_dev(text_1, t0);
      append_hydration_dev(text_1, t1);
      append_hydration_dev(div1, t2);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t3);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DonutChartSlide", slots, []);
  let { data } = $$props;
  const percent = parseInt(((_a = data.find((d) => d.name === "percent")) == null ? void 0 : _a.content) ?? 0);
  const label = ((_b = data.find((d) => d.name === "label")) == null ? void 0 : _b.content) ?? "";
  const color = ((_c = data.find((d) => d.name === "color")) == null ? void 0 : _c.content) ?? "#4CAF50";
  const circumference = 2 * Math.PI * 80;
  const offset = circumference * (1 - percent / 100);
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<DonutChartSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<DonutChartSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(5, data = $$props2.data);
  };
  $$self.$capture_state = () => ({
    data,
    percent,
    label,
    color,
    circumference,
    offset
  });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(5, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [percent, label, color, circumference, offset, data];
}
var DonutChartSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { data: 5 }, add_css15);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DonutChartSlide",
      options,
      id: create_fragment16.name
    });
  }
  get data() {
    throw new Error("<DonutChartSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<DonutChartSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DonutChartSlide_default = DonutChartSlide;

// node_modules/taleem-pivot-player/src/slides/TitleAndSubtitle.svelte
var file16 = "node_modules/taleem-pivot-player/src/slides/TitleAndSubtitle.svelte";
function add_css16(target) {
  append_styles(target, "svelte-1x56q4r", ".slide-container.svelte-1x56q4r{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;width:100%;padding:40px;box-sizing:border-box;text-align:center;gap:20px}.slide-title.svelte-1x56q4r{font-size:3rem;margin:0}.slide-subtitle.svelte-1x56q4r{font-size:1.5rem;margin:0;opacity:0.8}@media(max-width: 768px){.slide-title.svelte-1x56q4r{font-size:2rem}.slide-subtitle.svelte-1x56q4r{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGl0bGVBbmRTdWJ0aXRsZS5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zcmMvc2xpZGVzL1RpdGxlQW5kU3VidGl0bGUuc3ZlbHRlIl19 */");
}
function create_fragment17(ctx) {
  let div;
  let h1;
  let t0;
  let t1;
  let p;
  let t2;
  const block = {
    c: function create() {
      div = element("div");
      h1 = element("h1");
      t0 = text(
        /*title*/
        ctx[0]
      );
      t1 = space();
      p = element("p");
      t2 = text(
        /*subtitle*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h1 = claim_element(div_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*title*/
        ctx[0]
      );
      h1_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      p = claim_element(div_nodes, "P", { class: true });
      var p_nodes = children(p);
      t2 = claim_text(
        p_nodes,
        /*subtitle*/
        ctx[1]
      );
      p_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "slide-title svelte-1x56q4r");
      add_location(h1, file16, 8, 4, 228);
      attr_dev(p, "class", "slide-subtitle svelte-1x56q4r");
      add_location(p, file16, 9, 4, 269);
      attr_dev(div, "class", "slide-container svelte-1x56q4r");
      add_location(div, file16, 7, 2, 194);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, p);
      append_hydration_dev(p, t2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TitleAndSubtitle", slots, []);
  let { data } = $$props;
  const title = ((_a = data.find((d) => d.name === "title")) == null ? void 0 : _a.content) ?? "";
  const subtitle = ((_b = data.find((d) => d.name === "subtitle")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<TitleAndSubtitle> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<TitleAndSubtitle> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, title, subtitle });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, subtitle, data];
}
var TitleAndSubtitle = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { data: 2 }, add_css16);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TitleAndSubtitle",
      options,
      id: create_fragment17.name
    });
  }
  get data() {
    throw new Error("<TitleAndSubtitle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<TitleAndSubtitle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TitleAndSubtitle_default = TitleAndSubtitle;

// node_modules/taleem-pivot-player/src/slides/BulletList.svelte
var file17 = "node_modules/taleem-pivot-player/src/slides/BulletList.svelte";
function add_css17(target) {
  append_styles(target, "svelte-20k8u6", ".slide-container.svelte-20k8u6{display:flex;justify-content:center;align-items:center;height:100%;width:100%;padding:40px;box-sizing:border-box}.bullet-list.svelte-20k8u6{list-style-type:disc;padding-left:1.5rem;font-size:1.5rem}.bullet-item.svelte-20k8u6{margin-bottom:0.8rem}@media(max-width: 768px){.bullet-list.svelte-20k8u6{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQnVsbGV0TGlzdC5zdmVsdGUiLCJtYXBwaW5ncyI6IiIsIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiL2hvbWUvYmlsYWwtdGFyaXEvMDBUQUxFRU09PWNvbXBvbmVudHMvUGxheWVyUHJvamVjdC9ub2RlX21vZHVsZXMvdGFsZWVtLXBpdm90LXBsYXllci9zcmMvc2xpZGVzL0J1bGxldExpc3Quc3ZlbHRlIl19 */");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block7(ctx) {
  let li;
  let t_value = (
    /*bullet*/
    ctx[2] + ""
  );
  let t;
  const block = {
    c: function create() {
      li = element("li");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", { class: true });
      var li_nodes = children(li);
      t = claim_text(li_nodes, t_value);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "bullet-item svelte-20k8u6");
      add_location(li, file17, 9, 8, 228);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(li);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block7.name,
    type: "each",
    source: "(9:6) {#each bullets as bullet}",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let div;
  let ul;
  let each_value = ensure_array_like_dev(
    /*bullets*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      ul = claim_element(div_nodes, "UL", { class: true });
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "bullet-list svelte-20k8u6");
      add_location(ul, file17, 7, 4, 163);
      attr_dev(div, "class", "slide-container svelte-20k8u6");
      add_location(div, file17, 6, 2, 129);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*bullets*/
      1) {
        each_value = ensure_array_like_dev(
          /*bullets*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BulletList", slots, []);
  let { data } = $$props;
  const bullets = data.filter((d) => d.name === "bullet").map((b) => b.content);
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BulletList> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BulletList> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, bullets });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(1, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [bullets, data];
}
var BulletList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { data: 1 }, add_css17);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BulletList",
      options,
      id: create_fragment18.name
    });
  }
  get data() {
    throw new Error("<BulletList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BulletList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BulletList_default = BulletList;

// node_modules/taleem-pivot-player/src/slides/BigNumber.svelte
var file18 = "node_modules/taleem-pivot-player/src/slides/BigNumber.svelte";
function add_css18(target) {
  append_styles(target, "svelte-hzv82f", ".slide-container.svelte-hzv82f{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;width:100%;gap:20px;padding:40px;box-sizing:border-box;text-align:center}.big-number.svelte-hzv82f{font-size:6rem;font-weight:bold}.label-text.svelte-hzv82f{font-size:1.5rem;opacity:0.8}@media(max-width: 768px){.big-number.svelte-hzv82f{font-size:3rem}.label-text.svelte-hzv82f{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQmlnTnVtYmVyLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvQmlnTnVtYmVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment19(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(
        /*number*/
        ctx[0]
      );
      t1 = space();
      div1 = element("div");
      t2 = text(
        /*label*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t0 = claim_text(
        div0_nodes,
        /*number*/
        ctx[0]
      );
      div0_nodes.forEach(detach_dev);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      t2 = claim_text(
        div1_nodes,
        /*label*/
        ctx[1]
      );
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "big-number svelte-hzv82f");
      add_location(div0, file18, 8, 4, 224);
      attr_dev(div1, "class", "label-text svelte-hzv82f");
      add_location(div1, file18, 9, 4, 267);
      attr_dev(div2, "class", "slide-container svelte-hzv82f");
      add_location(div2, file18, 7, 2, 190);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, t0);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, t2);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  var _a, _b;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("BigNumber", slots, []);
  let { data } = $$props;
  const number = ((_a = data.find((d) => d.name === "number")) == null ? void 0 : _a.content) ?? "";
  const label = ((_b = data.find((d) => d.name === "label")) == null ? void 0 : _b.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<BigNumber> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<BigNumber> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, number, label });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(2, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [number, label, data];
}
var BigNumber = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance19, create_fragment19, safe_not_equal, { data: 2 }, add_css18);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BigNumber",
      options,
      id: create_fragment19.name
    });
  }
  get data() {
    throw new Error("<BigNumber>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<BigNumber>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var BigNumber_default = BigNumber;

// node_modules/taleem-pivot-player/src/slides/QuoteWithImage.svelte
var file19 = "node_modules/taleem-pivot-player/src/slides/QuoteWithImage.svelte";
function add_css19(target) {
  append_styles(target, "svelte-1s00uxy", ".slide-container.svelte-1s00uxy.svelte-1s00uxy{display:flex;flex-direction:column;align-items:center;text-align:center;gap:20px;height:100%;width:100%;padding:40px;box-sizing:border-box}.quote.svelte-1s00uxy.svelte-1s00uxy{font-size:2rem;font-style:italic;margin:0}.author.svelte-1s00uxy.svelte-1s00uxy{margin-top:10px;font-size:1.2rem;opacity:0.7}.image-zone.svelte-1s00uxy img.svelte-1s00uxy{max-width:120px;height:auto;border-radius:50%}@media(max-width: 768px){.quote.svelte-1s00uxy.svelte-1s00uxy{font-size:1.5rem}.author.svelte-1s00uxy.svelte-1s00uxy{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUXVvdGVXaXRoSW1hZ2Uuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL3NsaWRlcy9RdW90ZVdpdGhJbWFnZS5zdmVsdGUiXX0= */");
}
function create_fragment20(ctx) {
  let div3;
  let div1;
  let blockquote;
  let t0;
  let t1;
  let t2;
  let t3;
  let div0;
  let t4;
  let t5;
  let t6;
  let div2;
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      div3 = element("div");
      div1 = element("div");
      blockquote = element("blockquote");
      t0 = text('"');
      t1 = text(
        /*quote*/
        ctx[0]
      );
      t2 = text('"');
      t3 = space();
      div0 = element("div");
      t4 = text("— ");
      t5 = text(
        /*author*/
        ctx[1]
      );
      t6 = space();
      div2 = element("div");
      img = element("img");
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      blockquote = claim_element(div1_nodes, "BLOCKQUOTE", { class: true });
      var blockquote_nodes = children(blockquote);
      t0 = claim_text(blockquote_nodes, '"');
      t1 = claim_text(
        blockquote_nodes,
        /*quote*/
        ctx[0]
      );
      t2 = claim_text(blockquote_nodes, '"');
      blockquote_nodes.forEach(detach_dev);
      t3 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      t4 = claim_text(div0_nodes, "— ");
      t5 = claim_text(
        div0_nodes,
        /*author*/
        ctx[1]
      );
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t6 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      img = claim_element(div2_nodes, "IMG", { src: true, alt: true, class: true });
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(blockquote, "class", "quote svelte-1s00uxy");
      add_location(blockquote, file19, 10, 6, 327);
      attr_dev(div0, "class", "author svelte-1s00uxy");
      add_location(div0, file19, 11, 6, 382);
      attr_dev(div1, "class", "quote-zone");
      add_location(div1, file19, 9, 4, 296);
      if (!src_url_equal(img.src, img_src_value = /*imageSrc*/
      ctx[2])) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "Author Image");
      attr_dev(img, "class", "svelte-1s00uxy");
      add_location(img, file19, 14, 6, 465);
      attr_dev(div2, "class", "image-zone svelte-1s00uxy");
      add_location(div2, file19, 13, 4, 434);
      attr_dev(div3, "class", "slide-container svelte-1s00uxy");
      add_location(div3, file19, 8, 2, 262);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, blockquote);
      append_hydration_dev(blockquote, t0);
      append_hydration_dev(blockquote, t1);
      append_hydration_dev(blockquote, t2);
      append_hydration_dev(div1, t3);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t4);
      append_hydration_dev(div0, t5);
      append_hydration_dev(div3, t6);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, img);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("QuoteWithImage", slots, []);
  let { data } = $$props;
  const quote = ((_a = data.find((d) => d.name === "quote")) == null ? void 0 : _a.content) ?? "";
  const author = ((_b = data.find((d) => d.name === "author")) == null ? void 0 : _b.content) ?? "";
  const imageSrc = ((_c = data.find((d) => d.name === "image")) == null ? void 0 : _c.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<QuoteWithImage> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<QuoteWithImage> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, quote, author, imageSrc });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [quote, author, imageSrc, data];
}
var QuoteWithImage = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, { data: 3 }, add_css19);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "QuoteWithImage",
      options,
      id: create_fragment20.name
    });
  }
  get data() {
    throw new Error("<QuoteWithImage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<QuoteWithImage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var QuoteWithImage_default = QuoteWithImage;

// node_modules/taleem-pivot-player/src/slides/ContactSlide.svelte
var file20 = "node_modules/taleem-pivot-player/src/slides/ContactSlide.svelte";
function add_css20(target) {
  append_styles(target, "svelte-q5d75h", ".slide-container.svelte-q5d75h{display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;width:100%;text-align:center;gap:12px;padding:40px;box-sizing:border-box}.headline.svelte-q5d75h{font-size:2.5rem;margin:0 0 10px 0}.contact-line.svelte-q5d75h{font-size:1.2rem;margin:0}@media(max-width: 768px){.headline.svelte-q5d75h{font-size:1.6rem}.contact-line.svelte-q5d75h{font-size:1rem}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udGFjdFNsaWRlLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiIiwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyIvaG9tZS9iaWxhbC10YXJpcS8wMFRBTEVFTT09Y29tcG9uZW50cy9QbGF5ZXJQcm9qZWN0L25vZGVfbW9kdWxlcy90YWxlZW0tcGl2b3QtcGxheWVyL3NyYy9zbGlkZXMvQ29udGFjdFNsaWRlLnN2ZWx0ZSJdfQ== */");
}
function create_fragment21(ctx) {
  let div;
  let h1;
  let t0;
  let t1;
  let p0;
  let t2;
  let t3;
  let t4;
  let p1;
  let t5;
  let t6;
  const block = {
    c: function create() {
      div = element("div");
      h1 = element("h1");
      t0 = text(
        /*headline*/
        ctx[0]
      );
      t1 = space();
      p0 = element("p");
      t2 = text("Email: ");
      t3 = text(
        /*email*/
        ctx[1]
      );
      t4 = space();
      p1 = element("p");
      t5 = text("Phone: ");
      t6 = text(
        /*phone*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      h1 = claim_element(div_nodes, "H1", { class: true });
      var h1_nodes = children(h1);
      t0 = claim_text(
        h1_nodes,
        /*headline*/
        ctx[0]
      );
      h1_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      p0 = claim_element(div_nodes, "P", { class: true });
      var p0_nodes = children(p0);
      t2 = claim_text(p0_nodes, "Email: ");
      t3 = claim_text(
        p0_nodes,
        /*email*/
        ctx[1]
      );
      p0_nodes.forEach(detach_dev);
      t4 = claim_space(div_nodes);
      p1 = claim_element(div_nodes, "P", { class: true });
      var p1_nodes = children(p1);
      t5 = claim_text(p1_nodes, "Phone: ");
      t6 = claim_text(
        p1_nodes,
        /*phone*/
        ctx[2]
      );
      p1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "headline svelte-q5d75h");
      add_location(h1, file20, 9, 4, 297);
      attr_dev(p0, "class", "contact-line svelte-q5d75h");
      add_location(p0, file20, 10, 4, 338);
      attr_dev(p1, "class", "contact-line svelte-q5d75h");
      add_location(p1, file20, 11, 4, 385);
      attr_dev(div, "class", "slide-container svelte-q5d75h");
      add_location(div, file20, 8, 2, 263);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, p0);
      append_hydration_dev(p0, t2);
      append_hydration_dev(p0, t3);
      append_hydration_dev(div, t4);
      append_hydration_dev(div, p1);
      append_hydration_dev(p1, t5);
      append_hydration_dev(p1, t6);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  var _a, _b, _c;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ContactSlide", slots, []);
  let { data } = $$props;
  const headline = ((_a = data.find((d) => d.name === "headline")) == null ? void 0 : _a.content) ?? "";
  const email = ((_b = data.find((d) => d.name === "email")) == null ? void 0 : _b.content) ?? "";
  const phone = ((_c = data.find((d) => d.name === "phone")) == null ? void 0 : _c.content) ?? "";
  $$self.$$.on_mount.push(function() {
    if (data === void 0 && !("data" in $$props || $$self.$$.bound[$$self.$$.props["data"]])) {
      console.warn("<ContactSlide> was created without expected prop 'data'");
    }
  });
  const writable_props = ["data"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<ContactSlide> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  $$self.$capture_state = () => ({ data, headline, email, phone });
  $$self.$inject_state = ($$props2) => {
    if ("data" in $$props2) $$invalidate(3, data = $$props2.data);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [headline, email, phone, data];
}
var ContactSlide = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { data: 3 }, add_css20);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ContactSlide",
      options,
      id: create_fragment21.name
    });
  }
  get data() {
    throw new Error("<ContactSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<ContactSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ContactSlide_default = ContactSlide;

// node_modules/taleem-pivot-player/src/PivotPlayer.svelte
var file21 = "node_modules/taleem-pivot-player/src/PivotPlayer.svelte";
function add_css21(target) {
  append_styles(target, "svelte-14qj7u8", ".stage.svelte-14qj7u8{position:relative;width:100vw;height:100vh;overflow:hidden}.nav-overlay.svelte-14qj7u8{opacity:0;transition:opacity 0.4s ease;pointer-events:none}.nav-overlay.visible.svelte-14qj7u8{opacity:1;pointer-events:auto}.nav-overlay.svelte-14qj7u8{position:absolute;top:0;left:0;right:0;background:rgba(0, 0, 0, 0.6);padding:0.8rem 1.2rem;display:flex;justify-content:center;align-items:center;gap:1.2rem;color:white;font-family:sans-serif;font-size:1rem;z-index:10}button.svelte-14qj7u8{padding:0.5rem 1.2rem;font-size:1rem;cursor:pointer;background:#222;color:white;border:none;border-radius:5px}button.svelte-14qj7u8:disabled{opacity:0.3;cursor:not-allowed}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiUGl2b3RQbGF5ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiIiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIi9ob21lL2JpbGFsLXRhcmlxLzAwVEFMRUVNPT1jb21wb25lbnRzL1BsYXllclByb2plY3Qvbm9kZV9tb2R1bGVzL3RhbGVlbS1waXZvdC1wbGF5ZXIvc3JjL1Bpdm90UGxheWVyLnN2ZWx0ZSJdfQ== */");
}
function create_else_block2(ctx) {
  let p;
  let textContent = "Unknown slide type";
  const block = {
    c: function create() {
      p = element("p");
      p.textContent = textContent;
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", { ["data-svelte-h"]: true });
      if (get_svelte_dataset(p) !== "svelte-19q4b9z") p.textContent = textContent;
      this.h();
    },
    h: function hydrate() {
      add_location(p, file21, 107, 8, 4214);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(p);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(107:6) {:else}",
    ctx
  });
  return block;
}
function create_if_block_17(ctx) {
  let bulletlist;
  let current;
  bulletlist = new BulletList_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(bulletlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(bulletlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(bulletlist, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const bulletlist_changes = {};
      if (dirty & /*currentSlide*/
      8) bulletlist_changes.data = /*currentSlide*/
      ctx2[3].data;
      bulletlist.$set(bulletlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(bulletlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bulletlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(bulletlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_17.name,
    type: "if",
    source: "(104:51) ",
    ctx
  });
  return block;
}
function create_if_block_16(ctx) {
  let bignumber;
  let current;
  bignumber = new BigNumber_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(bignumber.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(bignumber.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(bignumber, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const bignumber_changes = {};
      if (dirty & /*currentSlide*/
      8) bignumber_changes.data = /*currentSlide*/
      ctx2[3].data;
      bignumber.$set(bignumber_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(bignumber.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(bignumber.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(bignumber, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_16.name,
    type: "if",
    source: "(102:50) ",
    ctx
  });
  return block;
}
function create_if_block_15(ctx) {
  let quotewithimage;
  let current;
  quotewithimage = new QuoteWithImage_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(quotewithimage.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(quotewithimage.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(quotewithimage, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const quotewithimage_changes = {};
      if (dirty & /*currentSlide*/
      8) quotewithimage_changes.data = /*currentSlide*/
      ctx2[3].data;
      quotewithimage.$set(quotewithimage_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(quotewithimage.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(quotewithimage.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(quotewithimage, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(100:55) ",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let contactslide;
  let current;
  contactslide = new ContactSlide_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(contactslide.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(contactslide.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(contactslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const contactslide_changes = {};
      if (dirty & /*currentSlide*/
      8) contactslide_changes.data = /*currentSlide*/
      ctx2[3].data;
      contactslide.$set(contactslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(contactslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(contactslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(contactslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(98:53) ",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let titleandsubtitle;
  let current;
  titleandsubtitle = new TitleAndSubtitle_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(titleandsubtitle.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(titleandsubtitle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(titleandsubtitle, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const titleandsubtitle_changes = {};
      if (dirty & /*currentSlide*/
      8) titleandsubtitle_changes.data = /*currentSlide*/
      ctx2[3].data;
      titleandsubtitle.$set(titleandsubtitle_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(titleandsubtitle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(titleandsubtitle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(titleandsubtitle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(95:57) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let donutchartslide;
  let current;
  donutchartslide = new DonutChartSlide_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(donutchartslide.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(donutchartslide.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(donutchartslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const donutchartslide_changes = {};
      if (dirty & /*currentSlide*/
      8) donutchartslide_changes.data = /*currentSlide*/
      ctx2[3].data;
      donutchartslide.$set(donutchartslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(donutchartslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(donutchartslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(donutchartslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(93:51) ",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let twocolumntextslide;
  let current;
  twocolumntextslide = new TwoColumnTextSlide_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(twocolumntextslide.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(twocolumntextslide.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(twocolumntextslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const twocolumntextslide_changes = {};
      if (dirty & /*currentSlide*/
      8) twocolumntextslide_changes.data = /*currentSlide*/
      ctx2[3].data;
      twocolumntextslide.$set(twocolumntextslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(twocolumntextslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(twocolumntextslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(twocolumntextslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(91:54) ",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let barchartslide;
  let current;
  barchartslide = new BarChartSlide_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(barchartslide.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(barchartslide.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(barchartslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const barchartslide_changes = {};
      if (dirty & /*currentSlide*/
      8) barchartslide_changes.data = /*currentSlide*/
      ctx2[3].data;
      barchartslide.$set(barchartslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(barchartslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(barchartslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(barchartslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(89:49) ",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let statisticslide;
  let current;
  statisticslide = new StatisticSlide_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(statisticslide.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(statisticslide.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(statisticslide, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const statisticslide_changes = {};
      if (dirty & /*currentSlide*/
      8) statisticslide_changes.data = /*currentSlide*/
      ctx2[3].data;
      statisticslide.$set(statisticslide_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(statisticslide.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(statisticslide.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(statisticslide, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(87:50) ",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let table;
  let current;
  table = new Table_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(table.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(table.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(table, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const table_changes = {};
      if (dirty & /*currentSlide*/
      8) table_changes.data = /*currentSlide*/
      ctx2[3].data;
      table.$set(table_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(table.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(table.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(table, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(85:46) ",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let imagewithtitle;
  let current;
  imagewithtitle = new ImageWithTitle_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(imagewithtitle.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(imagewithtitle.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(imagewithtitle, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const imagewithtitle_changes = {};
      if (dirty & /*currentSlide*/
      8) imagewithtitle_changes.data = /*currentSlide*/
      ctx2[3].data;
      imagewithtitle.$set(imagewithtitle_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(imagewithtitle.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(imagewithtitle.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(imagewithtitle, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(83:55) ",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let imagewithcaption;
  let current;
  imagewithcaption = new ImageWithCaption_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(imagewithcaption.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(imagewithcaption.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(imagewithcaption, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const imagewithcaption_changes = {};
      if (dirty & /*currentSlide*/
      8) imagewithcaption_changes.data = /*currentSlide*/
      ctx2[3].data;
      imagewithcaption.$set(imagewithcaption_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(imagewithcaption.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(imagewithcaption.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(imagewithcaption, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(81:57) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let imagerightbulletsleft;
  let current;
  imagerightbulletsleft = new ImageRightBulletsLeft_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(imagerightbulletsleft.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(imagerightbulletsleft.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(imagerightbulletsleft, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const imagerightbulletsleft_changes = {};
      if (dirty & /*currentSlide*/
      8) imagerightbulletsleft_changes.data = /*currentSlide*/
      ctx2[3].data;
      imagerightbulletsleft.$set(imagerightbulletsleft_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(imagerightbulletsleft.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(imagerightbulletsleft.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(imagerightbulletsleft, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(79:62) ",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let imageleftbulletsright;
  let current;
  imageleftbulletsright = new ImageLeftBulletsRight_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(imageleftbulletsright.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(imageleftbulletsright.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(imageleftbulletsright, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const imageleftbulletsright_changes = {};
      if (dirty & /*currentSlide*/
      8) imageleftbulletsright_changes.data = /*currentSlide*/
      ctx2[3].data;
      imageleftbulletsright.$set(imageleftbulletsright_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(imageleftbulletsright.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(imageleftbulletsright.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(imageleftbulletsright, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(77:62) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let image;
  let current;
  image = new Image_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(image.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(image.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(image, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const image_changes = {};
      if (dirty & /*currentSlide*/
      8) image_changes.data = /*currentSlide*/
      ctx2[3].data;
      image.$set(image_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(image.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(image.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(image, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(75:51) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let title;
  let current;
  title = new Title_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(title.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(title.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(title, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const title_changes = {};
      if (dirty & /*currentSlide*/
      8) title_changes.data = /*currentSlide*/
      ctx2[3].data;
      title.$set(title_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(title.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(title.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(title, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(73:51) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let cornerwords;
  let current;
  cornerwords = new CornerWords_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(cornerwords.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(cornerwords.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(cornerwords, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const cornerwords_changes = {};
      if (dirty & /*currentSlide*/
      8) cornerwords_changes.data = /*currentSlide*/
      ctx2[3].data;
      cornerwords.$set(cornerwords_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(cornerwords.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(cornerwords.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(cornerwords, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(71:57) ",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let quote;
  let current;
  quote = new Quote_default({
    props: { data: (
      /*currentSlide*/
      ctx[3].data
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(quote.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(quote.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(quote, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const quote_changes = {};
      if (dirty & /*currentSlide*/
      8) quote_changes.data = /*currentSlide*/
      ctx2[3].data;
      quote.$set(quote_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(quote.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(quote.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(quote, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: '(69:6) {#if currentSlide.type === \\"quoteSlide\\"}',
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [
    create_if_block3,
    create_if_block_1,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4,
    create_if_block_5,
    create_if_block_6,
    create_if_block_7,
    create_if_block_8,
    create_if_block_9,
    create_if_block_10,
    create_if_block_11,
    create_if_block_12,
    create_if_block_13,
    create_if_block_14,
    create_if_block_15,
    create_if_block_16,
    create_if_block_17,
    create_else_block2
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*currentSlide*/
      ctx2[3].type === "quoteSlide"
    ) return 0;
    if (
      /*currentSlide*/
      ctx2[3].type === "cornerWordsSlide"
    ) return 1;
    if (
      /*currentSlide*/
      ctx2[3].type === "titleSlide"
    ) return 2;
    if (
      /*currentSlide*/
      ctx2[3].type === "imageSlide"
    ) return 3;
    if (
      /*currentSlide*/
      ctx2[3].type === "imageLeftBulletsRight"
    ) return 4;
    if (
      /*currentSlide*/
      ctx2[3].type === "imageRightBulletsLeft"
    ) return 5;
    if (
      /*currentSlide*/
      ctx2[3].type === "imageWithCaption"
    ) return 6;
    if (
      /*currentSlide*/
      ctx2[3].type === "imageWithTitle"
    ) return 7;
    if (
      /*currentSlide*/
      ctx2[3].type === "table"
    ) return 8;
    if (
      /*currentSlide*/
      ctx2[3].type === "statistic"
    ) return 9;
    if (
      /*currentSlide*/
      ctx2[3].type === "barChart"
    ) return 10;
    if (
      /*currentSlide*/
      ctx2[3].type === "twoColumnText"
    ) return 11;
    if (
      /*currentSlide*/
      ctx2[3].type === "donutChart"
    ) return 12;
    if (
      /*currentSlide*/
      ctx2[3].type === "titleAndSubtitle"
    ) return 13;
    if (
      /*currentSlide*/
      ctx2[3].type === "contactSlide"
    ) return 14;
    if (
      /*currentSlide*/
      ctx2[3].type === "quoteWithImage"
    ) return 15;
    if (
      /*currentSlide*/
      ctx2[3].type === "bigNumber"
    ) return 16;
    if (
      /*currentSlide*/
      ctx2[3].type === "bulletList"
    ) return 17;
    return 18;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(68:4) <SlideWrapper key={currentSlideIndex}>",
    ctx
  });
  return block;
}
function create_fragment22(ctx) {
  let div1;
  let staticbackground;
  let t0;
  let slidewrapper;
  let t1;
  let div0;
  let button0;
  let t2;
  let button0_disabled_value;
  let t3;
  let span;
  let t4;
  let t5_value = (
    /*currentSlideIndex*/
    ctx[1] + 1 + ""
  );
  let t5;
  let t6;
  let t7_value = (
    /*deck*/
    ctx[0].length + ""
  );
  let t7;
  let t8;
  let button1;
  let t9;
  let button1_disabled_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  staticbackground = new StaticBackground_default({
    props: {
      backgroundColor: (
        /*backgroundColor*/
        ctx[5]
      ),
      backgroundImage: (
        /*backgroundImage*/
        ctx[6]
      ),
      backgroundImageOpacity: (
        /*backgroundImageOpacity*/
        ctx[7]
      )
    },
    $$inline: true
  });
  slidewrapper = new SlideWrapper_default({
    props: {
      key: (
        /*currentSlideIndex*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div1 = element("div");
      create_component(staticbackground.$$.fragment);
      t0 = space();
      create_component(slidewrapper.$$.fragment);
      t1 = space();
      div0 = element("div");
      button0 = element("button");
      t2 = text("⬅ Prev");
      t3 = space();
      span = element("span");
      t4 = text("Slide ");
      t5 = text(t5_value);
      t6 = text(" of ");
      t7 = text(t7_value);
      t8 = space();
      button1 = element("button");
      t9 = text("Next ➡");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      claim_component(staticbackground.$$.fragment, div1_nodes);
      t0 = claim_space(div1_nodes);
      claim_component(slidewrapper.$$.fragment, div1_nodes);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      button0 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button0_nodes = children(button0);
      t2 = claim_text(button0_nodes, "⬅ Prev");
      button0_nodes.forEach(detach_dev);
      t3 = claim_space(div0_nodes);
      span = claim_element(div0_nodes, "SPAN", {});
      var span_nodes = children(span);
      t4 = claim_text(span_nodes, "Slide ");
      t5 = claim_text(span_nodes, t5_value);
      t6 = claim_text(span_nodes, " of ");
      t7 = claim_text(span_nodes, t7_value);
      span_nodes.forEach(detach_dev);
      t8 = claim_space(div0_nodes);
      button1 = claim_element(div0_nodes, "BUTTON", { class: true });
      var button1_nodes = children(button1);
      t9 = claim_text(button1_nodes, "Next ➡");
      button1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      button0.disabled = button0_disabled_value = /*currentSlideIndex*/
      ctx[1] === 0;
      attr_dev(button0, "class", "svelte-14qj7u8");
      add_location(button0, file21, 113, 6, 4374);
      add_location(span, file21, 114, 6, 4455);
      button1.disabled = button1_disabled_value = /*currentSlideIndex*/
      ctx[1] === /*deck*/
      ctx[0].length - 1;
      attr_dev(button1, "class", "svelte-14qj7u8");
      add_location(button1, file21, 115, 6, 4521);
      attr_dev(div0, "class", "nav-overlay svelte-14qj7u8");
      toggle_class(
        div0,
        "visible",
        /*showNav*/
        ctx[2]
      );
      add_location(div0, file21, 111, 4, 4279);
      attr_dev(div1, "class", div1_class_value = null_to_empty(`stage ${/*themeClass*/
      ctx[4]}`) + " svelte-14qj7u8");
      add_location(div1, file21, 59, 4, 2076);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      mount_component(staticbackground, div1, null);
      append_hydration_dev(div1, t0);
      mount_component(slidewrapper, div1, null);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, button0);
      append_hydration_dev(button0, t2);
      append_hydration_dev(div0, t3);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t4);
      append_hydration_dev(span, t5);
      append_hydration_dev(span, t6);
      append_hydration_dev(span, t7);
      append_hydration_dev(div0, t8);
      append_hydration_dev(div0, button1);
      append_hydration_dev(button1, t9);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*prev*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*next*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mousemove",
            /*handleMouseMove*/
            ctx[10],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const slidewrapper_changes = {};
      if (dirty & /*currentSlideIndex*/
      2) slidewrapper_changes.key = /*currentSlideIndex*/
      ctx2[1];
      if (dirty & /*$$scope, currentSlide*/
      4104) {
        slidewrapper_changes.$$scope = { dirty, ctx: ctx2 };
      }
      slidewrapper.$set(slidewrapper_changes);
      if (!current || dirty & /*currentSlideIndex*/
      2 && button0_disabled_value !== (button0_disabled_value = /*currentSlideIndex*/
      ctx2[1] === 0)) {
        prop_dev(button0, "disabled", button0_disabled_value);
      }
      if ((!current || dirty & /*currentSlideIndex*/
      2) && t5_value !== (t5_value = /*currentSlideIndex*/
      ctx2[1] + 1 + "")) set_data_dev(t5, t5_value);
      if ((!current || dirty & /*deck*/
      1) && t7_value !== (t7_value = /*deck*/
      ctx2[0].length + "")) set_data_dev(t7, t7_value);
      if (!current || dirty & /*currentSlideIndex, deck*/
      3 && button1_disabled_value !== (button1_disabled_value = /*currentSlideIndex*/
      ctx2[1] === /*deck*/
      ctx2[0].length - 1)) {
        prop_dev(button1, "disabled", button1_disabled_value);
      }
      if (!current || dirty & /*showNav*/
      4) {
        toggle_class(
          div0,
          "visible",
          /*showNav*/
          ctx2[2]
        );
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(staticbackground.$$.fragment, local);
      transition_in(slidewrapper.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(staticbackground.$$.fragment, local);
      transition_out(slidewrapper.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      destroy_component(staticbackground);
      destroy_component(slidewrapper);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance22($$self, $$props, $$invalidate) {
  let currentSlide;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PivotPlayer", slots, []);
  let { deck } = $$props;
  let themeClass = "theme-neonDark";
  let backgroundColor = "#b3d8b4";
  let backgroundImage = "/pivot/defaultBg.png";
  let backgroundImageOpacity = 1;
  let currentSlideIndex = 0;
  function next() {
    if (currentSlideIndex < deck.length - 1) $$invalidate(1, currentSlideIndex++, currentSlideIndex);
  }
  function prev() {
    if (currentSlideIndex > 0) $$invalidate(1, currentSlideIndex--, currentSlideIndex);
  }
  let showNav = true;
  let hideTimeout;
  function handleMouseMove() {
    clearTimeout(hideTimeout);
    $$invalidate(2, showNav = true);
    hideTimeout = setTimeout(
      () => {
        $$invalidate(2, showNav = false);
      },
      3e3
    );
  }
  $$self.$$.on_mount.push(function() {
    if (deck === void 0 && !("deck" in $$props || $$self.$$.bound[$$self.$$.props["deck"]])) {
      console.warn("<PivotPlayer> was created without expected prop 'deck'");
    }
  });
  const writable_props = ["deck"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot") console.warn(`<PivotPlayer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("deck" in $$props2) $$invalidate(0, deck = $$props2.deck);
  };
  $$self.$capture_state = () => ({
    SlideWrapper: SlideWrapper_default,
    Quote: Quote_default,
    CornerWords: CornerWords_default,
    Title: Title_default,
    ImageLeftBulletsRight: ImageLeftBulletsRight_default,
    Image: Image_default,
    StaticBackground: StaticBackground_default,
    ImageRightBulletsLeft: ImageRightBulletsLeft_default,
    ImageWithCaption: ImageWithCaption_default,
    ImageWithTitle: ImageWithTitle_default,
    Table: Table_default,
    StatisticSlide: StatisticSlide_default,
    BarChartSlide: BarChartSlide_default,
    TwoColumnTextSlide: TwoColumnTextSlide_default,
    DonutChartSlide: DonutChartSlide_default,
    TitleAndSubtitle: TitleAndSubtitle_default,
    BulletList: BulletList_default,
    BigNumber: BigNumber_default,
    QuoteWithImage: QuoteWithImage_default,
    ContactSlide: ContactSlide_default,
    deck,
    themeClass,
    backgroundColor,
    backgroundImage,
    backgroundImageOpacity,
    currentSlideIndex,
    next,
    prev,
    showNav,
    hideTimeout,
    handleMouseMove,
    currentSlide
  });
  $$self.$inject_state = ($$props2) => {
    if ("deck" in $$props2) $$invalidate(0, deck = $$props2.deck);
    if ("themeClass" in $$props2) $$invalidate(4, themeClass = $$props2.themeClass);
    if ("backgroundColor" in $$props2) $$invalidate(5, backgroundColor = $$props2.backgroundColor);
    if ("backgroundImage" in $$props2) $$invalidate(6, backgroundImage = $$props2.backgroundImage);
    if ("backgroundImageOpacity" in $$props2) $$invalidate(7, backgroundImageOpacity = $$props2.backgroundImageOpacity);
    if ("currentSlideIndex" in $$props2) $$invalidate(1, currentSlideIndex = $$props2.currentSlideIndex);
    if ("showNav" in $$props2) $$invalidate(2, showNav = $$props2.showNav);
    if ("hideTimeout" in $$props2) hideTimeout = $$props2.hideTimeout;
    if ("currentSlide" in $$props2) $$invalidate(3, currentSlide = $$props2.currentSlide);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*deck, currentSlideIndex*/
    3) {
      $: $$invalidate(3, currentSlide = deck[currentSlideIndex]);
    }
  };
  return [
    deck,
    currentSlideIndex,
    showNav,
    currentSlide,
    themeClass,
    backgroundColor,
    backgroundImage,
    backgroundImageOpacity,
    next,
    prev,
    handleMouseMove
  ];
}
var PivotPlayer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance22, create_fragment22, safe_not_equal, { deck: 0 }, add_css21);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PivotPlayer",
      options,
      id: create_fragment22.name
    });
  }
  get deck() {
    throw new Error("<PivotPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set deck(value) {
    throw new Error("<PivotPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PivotPlayer_default = PivotPlayer;
export {
  PivotPlayer_default as PivotPlayer
};
//# sourceMappingURL=taleem-pivot-player.js.map
